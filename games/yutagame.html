<!doctype html>
<html lang="ja" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ç®—æ•°ã‚«ãƒ¼ãƒˆãƒ¬ãƒ¼ã‚¹ v4.1</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700;900&display=swap');
    * { font-family: 'Zen Maru Gothic', sans-serif; }
    html, body { height: 100%; }
    body { margin: 0; background: #071022; }
    .track-gradient { background: linear-gradient(135deg, #0c1222 0%, #0b1b34 55%, #0d2d55 100%); }
    .press:active{ transform: scale(0.96); }

    #game-screen { height: 100vh; }
    #race-view{
      height: calc(100vh - 170px);
      min-height: 440px;
      position: relative;
      overflow: hidden;
      background: linear-gradient(180deg, #78c6ff 0%, #e5f7ff 45%, #7fe0a0 45%, #67b987 100%);
      touch-action: manipulation;
    }
    #game-canvas{ position:absolute; inset:0; width:100%; height:100%; z-index:10; }

    @keyframes shake { 0%,100%{ transform: translateX(0);} 25%{ transform: translateX(-6px);} 75%{ transform: translateX(6px);} }
    .shake { animation: shake 220ms ease-in-out; }

    .modal-card{
      box-shadow: 0 20px 80px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.18);
    }
  </style>
</head>

<body class="h-full overflow-auto">
<div id="app" class="h-full w-full track-gradient text-white">

  <!-- ã‚¿ã‚¤ãƒˆãƒ« -->
  <div id="title-screen" class="h-full flex flex-col items-center justify-center p-4">
    <h1 class="text-4xl md:text-6xl font-black text-yellow-300 mb-3 text-center drop-shadow-lg">
      ğŸï¸ ç®—æ•°ã‚«ãƒ¼ãƒˆãƒ¬ãƒ¼ã‚¹ ğŸï¸
    </h1>
    <p class="text-lg md:text-xl mb-6 text-cyan-200">ã‚¢ã‚¤ãƒ†ãƒ ç®±ã‚ã‚Šï¼ ã‚«ãƒ¼ãƒ–ï¼†éšœå®³ç‰©ï¼ 1å‘¨ã”ã¨ã«ç®—æ•°ï¼</p>

    <div class="bg-white/10 backdrop-blur rounded-2xl p-5 mb-5 max-w-md w-full">
      <h2 class="text-xl font-bold mb-3 text-center text-yellow-200">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</h2>
      <div class="grid grid-cols-4 gap-3 mb-3" id="char-select"></div>
      <p class="text-center text-sm text-gray-200">é¸æŠä¸­: <span id="selected-char" class="text-2xl">ğŸ¥¸</span></p>
    </div>

    <div class="bg-white/10 backdrop-blur rounded-2xl p-5 mb-6 max-w-md w-full">
      <h2 class="text-xl font-bold mb-3 text-center text-pink-200">ã‚«ãƒ¼ãƒˆ</h2>
      <div class="grid grid-cols-4 gap-3 mb-3" id="kart-select"></div>
      <p class="text-center text-sm text-gray-200">é¸æŠä¸­: <span id="selected-kart" class="text-2xl">ğŸ¦</span></p>
    </div>

    <div class="text-center text-sm text-gray-300 mb-4">
      æ“ä½œï¼šâ†‘åŠ é€Ÿ / â†“ãƒ–ãƒ¬ãƒ¼ã‚­ / â†â†’ãƒãƒ³ãƒ‰ãƒ«(ç²¾å¯†) / Shiftãƒ‰ãƒªãƒ•ãƒˆ / Spaceã‚¢ã‚¤ãƒ†ãƒ 
    </div>

    <button id="start-btn"
      class="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white text-2xl font-black py-4 px-12 rounded-full shadow-lg transform hover:scale-105 transition-all press">
      ğŸš€ ãƒ¬ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ¼ãƒˆï¼
    </button>
  </div>

  <!-- ã‚²ãƒ¼ãƒ  -->
  <div id="game-screen" class="hidden flex-col">
    <!-- HUD -->
    <div class="bg-black/80 p-3 flex flex-wrap gap-2 justify-between items-center">
      <div class="text-base md:text-lg font-bold">
        <span class="text-white/60 mr-2">BUILD v4.1</span>
        ğŸ <span id="lap-display">1</span>/<span id="lap-total">10</span>å‘¨
        <span class="mx-2">|</span>
        ğŸ† <span id="position">1</span>ä½/5
      </div>

      <div class="flex flex-wrap gap-3 items-center text-sm md:text-base">
        <div>âš¡ <span id="player-speed">0</span></div>
        <div>ğŸŒ€ ãƒ‰ãƒªãƒ•ãƒˆ: <span id="drift-meter">0</span>%</div>
        <div>ğŸ <span id="item-display">---</span></div>
      </div>
    </div>

    <!-- ãƒ¬ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ -->
    <div id="race-view">
      <canvas id="game-canvas"></canvas>
    </div>

    <!-- æ“ä½œ -->
    <div class="bg-black/70 p-3">
      <div class="flex flex-wrap justify-center gap-3 mb-2">
        <button id="btn-left"  class="bg-slate-600 hover:bg-slate-700 px-5 py-2 rounded-lg font-bold press">â¬…ï¸ å·¦</button>
        <button id="btn-accel" class="bg-green-600 hover:bg-green-700 px-6 py-2 rounded-lg font-bold press">â¬†ï¸ ã‚¢ã‚¯ã‚»ãƒ«</button>
        <button id="btn-brake" class="bg-red-600 hover:bg-red-700 px-6 py-2 rounded-lg font-bold press">â¬‡ï¸ ãƒ–ãƒ¬ãƒ¼ã‚­</button>
        <button id="btn-right" class="bg-slate-600 hover:bg-slate-700 px-5 py-2 rounded-lg font-bold press">â¡ï¸ å³</button>
        <button id="btn-drift" class="bg-purple-600 hover:bg-purple-700 px-6 py-2 rounded-lg font-bold press">ğŸŒ€ ãƒ‰ãƒªãƒ•ãƒˆ</button>
        <button id="btn-item" class="bg-yellow-500 hover:bg-yellow-600 px-6 py-2 rounded-lg font-bold press">ğŸ¯ ã‚¢ã‚¤ãƒ†ãƒ </button>
      </div>
      <p class="text-center text-xs md:text-sm text-gray-300">
        â€»PCã¯ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ¨å¥¨ï¼šâ†â†’ã§ç²¾å¯†ãƒãƒ³ãƒ‰ãƒ« / Shiftã§ãƒ‰ãƒªãƒ•ãƒˆ / Spaceã§ã‚¢ã‚¤ãƒ†ãƒ 
      </p>
    </div>
  </div>

  <!-- ç®—æ•°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="math-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
    <div class="modal-card bg-gradient-to-br from-purple-600 to-indigo-700 rounded-3xl p-7 max-w-md w-full text-center">
      <h2 class="text-3xl font-black mb-3 text-yellow-200">ğŸ“š 1å‘¨ã‚¯ãƒªã‚¢ï¼ç®—æ•°ã‚¿ã‚¤ãƒ ï¼</h2>
      <p class="text-sm text-white/90 mb-2">æ­£è§£ã—ãªã„ã¨ãƒ¬ãƒ¼ã‚¹å†é–‹ã§ãã¾ã›ã‚“ã€‚</p>

      <div class="bg-white/15 rounded-2xl p-4 mb-4">
        <div class="text-sm text-white/80 mb-1">å•é¡Œ</div>
        <p id="math-question" class="text-4xl font-black">15 + 35 = ?</p>
      </div>

      <input type="number" id="math-answer"
        class="w-full text-3xl text-center p-4 rounded-xl bg-white text-gray-800 mb-3"
        placeholder="ç­”ãˆã‚’å…¥åŠ›" />

      <button id="submit-answer"
        class="bg-gradient-to-r from-green-500 to-emerald-600 text-white text-xl font-black py-3 px-8 rounded-full hover:scale-105 transition-transform w-full press">
        å›ç­”ã™ã‚‹ï¼
      </button>

      <div class="mt-4 text-sm text-gray-100">
        â° åˆ¶é™æ™‚é–“: <span id="time-left" class="font-black">10</span>ç§’
      </div>
      <p id="math-feedback" class="mt-3 text-sm font-bold text-yellow-200"></p>
    </div>
  </div>

  <!-- çµæœ -->
  <div id="result-screen" class="hidden h-full flex-col items-center justify-center p-4 bg-gradient-to-b from-purple-900 to-blue-900">
    <h1 class="text-5xl font-black mb-4">ğŸ ãƒ¬ãƒ¼ã‚¹çµ‚äº†ï¼ ğŸ</h1>
    <div id="result-position" class="text-8xl mb-4">ğŸ¥‡</div>
    <p id="result-text" class="text-3xl font-black text-yellow-300 mb-8">1ä½ã§ã‚´ãƒ¼ãƒ«ï¼</p>

    <div class="bg-white/10 backdrop-blur rounded-2xl p-6 mb-8 max-w-md w-full">
      <h3 class="text-xl font-black mb-4">ğŸ“Š ã‚¹ã‚¿ãƒƒãƒ„</h3>
      <p class="mb-2">æ­£è§£ã—ãŸå•é¡Œ: <span id="correct-answers" class="font-black">0</span>å•</p>
      <p class="mb-2">ä½¿ç”¨ã‚¢ã‚¤ãƒ†ãƒ : <span id="items-used" class="font-black">0</span>å€‹</p>
      <p>ãƒ¬ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ : <span id="race-time" class="font-black">0:00</span></p>
      <p class="mt-2 text-sm text-white/70">éšœå®³ç‰©ãƒ’ãƒƒãƒˆ: <span id="hits" class="font-black">0</span>å›</p>
      <p class="mt-1 text-sm text-white/70">ã‚¢ã‚¤ãƒ†ãƒ ç®±å–å¾—: <span id="boxes" class="font-black">0</span>å›</p>
    </div>

    <button id="retry-btn"
      class="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white text-2xl font-black py-4 px-12 rounded-full shadow-lg transform hover:scale-105 transition-all press">
      ğŸ”„ ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤
    </button>
  </div>

</div>

<script>
/* ===========================
   ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
=========================== */
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function rand(min,max){ return Math.random()*(max-min)+min; }
function randi(min,max){ return Math.floor(rand(min,max+1)); }

/* ===========================
   ãƒ‡ãƒ¼ã‚¿
=========================== */
const characters = ['ğŸ¥¸','ğŸ¥·ğŸ¿','ğŸ’€','ğŸ’°','ğŸœ','ğŸ°','ğŸ·','ğŸ¦‡'];
const karts      = ['ğŸ¦','ğŸ¦€','ğŸ„','ğŸ–','ğŸ›’','ğŸ“','ğŸœ','ğŸ‡'];
const itemsPool  = ['ğŸŒ','ğŸ„','â­','ğŸ’£','ğŸ¦‘','ğŸª¶','ğŸ¢','ğŸ‘»'];

const titleScreen  = document.getElementById('title-screen');
const gameScreen   = document.getElementById('game-screen');
const resultScreen = document.getElementById('result-screen');

const lapDisplay   = document.getElementById('lap-display');
const lapTotalEl   = document.getElementById('lap-total');
const posEl        = document.getElementById('position');
const speedEl      = document.getElementById('player-speed');
const driftMeterEl = document.getElementById('drift-meter');
const itemDisplay  = document.getElementById('item-display');

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d', { alpha: true });

/* ===========================
   ã‚³ãƒ¼ã‚¹ï¼ˆè¦‹ãŸç›®ã‚’å¼·åŒ–ï¼‰
=========================== */
const LAP_LEN = 1000;
function centerOffset(t){
  // v4.0ã‚ˆã‚Šâ€œã‚³ãƒ¼ã‚¹æ„Ÿâ€ã‚’å¼·ã‚ã‚‹ï¼ˆæŒ¯ã‚Œå¹…ã‚’å°‘ã—å¢—ã‚„ã™ï¼‰
  const a = Math.sin(t*0.0075) * 0.70;
  const b = Math.sin(t*0.017  + 1.2) * 0.30;
  const c = Math.sin(t*0.039  + 2.0) * 0.14;
  return clamp(a+b+c, -0.98, 0.98);
}

/* ===========================
   éšœå®³ç‰©ï¼ˆæ—¢å­˜ï¼‰
=========================== */
let obstacles = [];
function buildObstacles(totalLaps){
  obstacles = [];
  for(let lap=0; lap<totalLaps; lap++){
    const base = lap * LAP_LEN;
    const n = randi(6,9);
    for(let i=0;i<n;i++){
      const tt = base + randi(150, LAP_LEN-140);
      const off = centerOffset(tt % LAP_LEN);
      const x = clamp(off + rand(-0.52, 0.52), -0.95, 0.95);
      const kind = Math.random() < 0.6 ? 'cone' : 'banana';
      obstacles.push({ t: tt, x, kind, used:false });
    }
  }
  obstacles.sort((a,b)=>a.t-b.t);
}

/* ===========================
   â˜…ã‚¢ã‚¤ãƒ†ãƒ ç®±
   - ç®±ã«å½“ãŸã‚‹ã¨å¿…ãšã‚¢ã‚¤ãƒ†ãƒ 
   - å–ã£ãŸç®±ã¯ä¸€å®šæ™‚é–“ã§å¾©æ´»
=========================== */
let itemBoxes = [];
const BOX_RESPAWN = 7.5; // ç§’
function buildItemBoxes(totalLaps){
  itemBoxes = [];
  for(let lap=0; lap<totalLaps; lap++){
    const base = lap * LAP_LEN;
    // 1å‘¨ã‚ãŸã‚Š 4ã€œ6å€‹ï¼šã‚«ãƒ¼ãƒ–åŒºé–“ã«ã‚‚ç½®ã
    const n = randi(4,6);
    for(let i=0;i<n;i++){
      const tt = base + randi(120, LAP_LEN-120);
      const off = centerOffset(tt % LAP_LEN);
      // é“è·¯ã®ä¸­å¿ƒå¯„ã‚Šã«ç½®ãï¼ˆå–ã‚Šã‚„ã™ã„ï¼‰
      const x = clamp(off + rand(-0.35, 0.35), -0.80, 0.80);
      itemBoxes.push({ t: tt, x, cooldown: 0 });
    }
  }
  itemBoxes.sort((a,b)=>a.t-b.t);
}

/* ===========================
   ç®—æ•°ï¼ˆ1å‘¨ã”ã¨ï¼‰
=========================== */
const mathModal = document.getElementById('math-modal');
let quizTimer = null;
let timeLeft = 10;
let currentQuiz = { q:'', a:0 };

function makeMathProblem(lapIndex){
  const level = clamp(lapIndex, 1, 10);
  const types = level <= 3 ? ['add','sub'] : (level <= 6 ? ['add','sub','mul'] : ['add','sub','mul','mix']);
  const type = types[Math.floor(Math.random()*types.length)];
  const rr = (min,max)=> Math.floor(Math.random()*(max-min+1))+min;

  if(type==='add'){
    const a = rr(10*level, 25*level);
    const b = rr(5*level, 18*level);
    return { q: `${a} + ${b}`, a: a+b };
  }
  if(type==='sub'){
    let a = rr(15*level, 28*level);
    let b = rr(5*level, 20*level);
    if(b>a) [a,b] = [b,a];
    return { q: `${a} - ${b}`, a: a-b };
  }
  if(type==='mul'){
    const a = rr(2, Math.min(9, 2+Math.floor(level/2)));
    const b = rr(2, 9);
    return { q: `${a} Ã— ${b}`, a: a*b };
  }
  const a = rr(2, 9), b = rr(2, 9), c = rr(5, 30);
  return { q: `${a} Ã— ${b} + ${c}`, a: a*b + c };
}

function openQuiz(lapCompleted){
  gameState.pausedByQuiz = true;
  mathModal.classList.remove('hidden');

  currentQuiz = makeMathProblem(lapCompleted);
  document.getElementById('math-question').textContent = `${currentQuiz.q} = ?`;
  document.getElementById('math-answer').value = '';
  document.getElementById('math-feedback').textContent = '';

  clearInterval(quizTimer);
  timeLeft = 10;
  document.getElementById('time-left').textContent = timeLeft;

  quizTimer = setInterval(()=>{
    timeLeft--;
    document.getElementById('time-left').textContent = timeLeft;
    if(timeLeft <= 0){
      clearInterval(quizTimer);
      document.getElementById('math-feedback').textContent = 'â° ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼å°‘ã—æ¸›é€Ÿâ€¦ æ¬¡ã®å•é¡Œï¼';
      gameState.player.speed *= 0.55;
      setTimeout(()=> openQuiz(lapCompleted), 650);
    }
  }, 1000);

  setTimeout(()=> document.getElementById('math-answer').focus(), 50);
}

function closeQuizSuccess(){
  clearInterval(quizTimer);
  mathModal.classList.add('hidden');
  gameState.pausedByQuiz = false;
  gameState.player.boost(0.9, 0.22);
}

/* ===========================
   ãƒ¬ãƒ¼ã‚µãƒ¼
=========================== */
class Racer {
  constructor(char, kart, isAI){
    this.char = char;
    this.kart = kart;
    this.isAI = isAI;

    this.totalDist = 0;
    this.speed = isAI ? rand(0.33, 0.42) : 0;
    this.vx = 0;
    this.x = isAI ? rand(-0.25, 0.25) : 0;
    this.drift = 0;
    this.boostTime = 0;
    this.boostPower = 0;

    this.item = null;
    this.stun = 0;

    this.aiLineBias = isAI ? rand(-0.35, 0.35) : 0;
    this.aiTopSpeed = isAI ? rand(0.36, 0.44) : 0.45;
    this.aiAggro = isAI ? rand(0.6, 1.0) : 0;

    this.hits = 0;
    this.boxes = 0;
  }

  giveItem(){
    this.item = itemsPool[randi(0, itemsPool.length-1)];
  }
  boost(sec, power){
    this.boostTime = Math.max(this.boostTime, sec);
    this.boostPower = Math.max(this.boostPower, power);
  }
  spin(sec){
    this.stun = Math.max(this.stun, sec);
    this.speed *= 0.35;
    this.vx *= -0.35;
  }
  useItem(){
    if(!this.item) return null;
    const it = this.item;
    this.item = null;
    return it;
  }

  update(dt, courseCenterX, aheadList){
    if(this.stun > 0){
      this.stun -= dt;
      this.speed = Math.max(0, this.speed - dt*0.25);
    }
    if(this.boostTime > 0){
      this.boostTime -= dt;
      if(this.boostTime <= 0) this.boostPower = 0;
    }

    if(this.isAI){
      let targetX = courseCenterX + this.aiLineBias;

      // éšœå®³ç‰©å›é¿
      const lookAhead = 140;
      const myT = this.totalDist;
      for(const ob of obstacles){
        if(ob.used) continue;
        const d = ob.t - myT;
        if(d < 0) continue;
        if(d > lookAhead) break;
        const near = Math.abs(ob.x - this.x) < 0.18;
        if(near){
          targetX += (this.x < ob.x ? -0.35 : 0.35) * (1 - d/lookAhead);
        }
      }

      // å‰èµ°è€…ã§æŠœã
      for(const a of aheadList){
        const dd = a.totalDist - this.totalDist;
        if(dd > 0 && dd < 90){
          const closeX = Math.abs(a.x - this.x) < 0.17;
          if(closeX){
            targetX += (this.x < a.x ? -0.30 : 0.30) * (1 - dd/90);
          }
        }
      }

      targetX = clamp(targetX, -0.95, 0.95);

      const steer = clamp((targetX - this.x) * 4.2, -1.0, 1.0);
      this.vx += steer * dt * 1.9;
      this.vx *= (1 - dt*2.0);

      const rank = getRanking().findIndex(r => r === this) + 1;
      const rubber = clamp((6 - rank) * 0.012, 0, 0.06);

      const curvePenalty = Math.abs(this.x - courseCenterX) * 0.085;
      const targetSp = (this.aiTopSpeed + rubber) - curvePenalty;

      const accel = 0.55;
      this.speed = lerp(this.speed, targetSp, 1 - Math.exp(-accel*dt));

      // ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆAIã¯ç®±ã§ç¢ºå®Ÿã«å–ã‚‹ã®ã§ã“ã“ã¯æ§ãˆã‚ï¼‰
      if(this.item && Math.random() < 0.003){
        const it = this.useItem();
        if(it === 'ğŸ„') this.boost(0.7, 0.12);
        if(it === 'â­') this.boost(1.0, 0.18);
      }
    }else{
      const steering = (gameState.keys.right?1:0) - (gameState.keys.left?1:0);
      const accel = gameState.keys.up ? 0.62 : 0.0;
      const brake = gameState.keys.down ? 0.95 : 0.0;

      const drifting = gameState.keys.drift && Math.abs(steering) > 0 && this.speed > 0.18 && this.stun<=0;
      if(drifting){
        this.drift = clamp(this.drift + dt*0.55, 0, 1);
      }else{
        if(this.drift > 0.22){
          const pow = this.drift > 0.75 ? 0.18 : (this.drift > 0.5 ? 0.13 : 0.09);
          const sec = this.drift > 0.75 ? 1.0 : (this.drift > 0.5 ? 0.75 : 0.55);
          this.boost(sec, pow);
        }
        this.drift = 0;
      }

      const steerPower = drifting ? 2.2 : 3.4;
      this.vx += steering * dt * steerPower;

      const sideFric = drifting ? 0.55 : 0.85;
      this.vx *= (1 - dt * (2.6*sideFric));

      const top = 0.46;
      const target = clamp(top + (this.boostTime>0 ? this.boostPower : 0), 0, 0.62);
      const curvePenalty = Math.abs(this.x - courseCenterX) * 0.12;

      this.speed += accel * dt * 0.55;
      this.speed -= brake * dt * 0.85;
      this.speed -= dt * 0.22;
      this.speed = clamp(this.speed, 0, target - curvePenalty);
    }

    this.x += this.vx * dt;
    this.x = clamp(this.x, -0.98, 0.98);

    const lineBonus = 1 - Math.abs(this.x - courseCenterX) * 0.07;
    const forward = this.speed * lineBonus;

    this.totalDist += forward * dt * 220;
    const lapNow = Math.floor(this.totalDist / LAP_LEN);
    if(lapNow >= gameState.totalLaps){
      this.totalDist = gameState.totalLaps * LAP_LEN;
      this.speed = 0;
    }
  }
}

/* ===========================
   ã‚²ãƒ¼ãƒ çŠ¶æ…‹
=========================== */
const gameState = {
  selectedChar: characters[0],
  selectedKart: karts[0],
  totalLaps: 10,
  players: [],
  player: null,
  keys: { up:false, down:false, left:false, right:false, drift:false },
  gameActive: false,
  pausedByQuiz: false,
  quizLapTriggered: -1,
  correctAnswers: 0,
  itemsUsed: 0,
  startTime: 0,
  hits: 0,
  boxes: 0
};

function getRanking(){
  return [...gameState.players].sort((a,b)=> b.totalDist - a.totalDist);
}

/* ===========================
   Canvas
=========================== */
function resizeCanvas(){
  const rect = document.getElementById('race-view').getBoundingClientRect();
  canvas.width  = Math.floor(rect.width  * devicePixelRatio);
  canvas.height = Math.floor(rect.height * devicePixelRatio);
  canvas.style.width  = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resizeCanvas);

/* ===========================
   æç”»ï¼ˆã‚³ãƒ¼ã‚¹æ„ŸUPï¼‰
=========================== */
function drawText(x,y,text,size=22,alpha=1){
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.font = `${size}px "Zen Maru Gothic", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(0,0,0,0.45)';
  ctx.shadowBlur = 8;
  ctx.shadowOffsetY = 4;
  ctx.fillText(text, x, y);
  ctx.restore();
}

function draw(){
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  // èƒŒæ™¯ã®èŠã‚’å°‘ã—â€œåœ°å½¢ã£ã½ãâ€
  ctx.fillStyle = 'rgba(0,0,0,0.05)';
  ctx.fillRect(0, h*0.45, w, h*0.55);

  const me = gameState.player;
  const t0 = me.totalDist;

  const horizon = h*0.18;
  const baseY = h*0.92;

  const roadWNear = w*0.74;
  const roadWFar  = w*0.11;

  const segments = 75;

  // é“ã®å¤–å´ï¼ˆèŠãƒ»ã‚¬ãƒ¼ãƒ‰ï¼‰ã‚‚æããŸã‚ã€è·¯é¢ã®å‰ã«â€œå¤–å´â€ã‚’æã
  for(let i=segments; i>=1; i--){
    const p0 = (i-1)/segments;
    const p1 = i/segments;

    const dt0 = t0 + p0*270;
    const dt1 = t0 + p1*270;

    const c0 = centerOffset(dt0 % LAP_LEN);
    const c1 = centerOffset(dt1 % LAP_LEN);

    const cx0 = w/2 + c0 * (w*0.26) * (1 - p0*0.78);
    const cx1 = w/2 + c1 * (w*0.26) * (1 - p1*0.78);

    const rw0 = lerp(roadWNear, roadWFar, p0);
    const rw1 = lerp(roadWNear, roadWFar, p1);

    const y0 = lerp(baseY, horizon, p0);
    const y1 = lerp(baseY, horizon, p1);

    // å¤–å´ã®èŠï¼ˆé“ã‚ˆã‚Šå°‘ã—åºƒãï¼‰
    const grassW0 = rw0 * 1.45;
    const grassW1 = rw1 * 1.45;
    ctx.fillStyle = (Math.floor(dt0/40)%2===0) ? 'rgba(78,180,110,0.38)' : 'rgba(60,160,95,0.36)';
    ctx.beginPath();
    ctx.moveTo(cx0 - grassW0/2, y0);
    ctx.lineTo(cx0 + grassW0/2, y0);
    ctx.lineTo(cx1 + grassW1/2, y1);
    ctx.lineTo(cx1 - grassW1/2, y1);
    ctx.closePath();
    ctx.fill();

    // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ï¼ˆç™½ã„å¸¯ï¼‰
    const guardW0 = Math.max(2, rw0*0.018);
    const guardW1 = Math.max(1, rw1*0.018);
    ctx.fillStyle = 'rgba(240,240,240,0.38)';
    // å·¦
    ctx.beginPath();
    ctx.moveTo(cx0 - rw0/2 - guardW0*2, y0);
    ctx.lineTo(cx0 - rw0/2 - guardW0*0.5, y0);
    ctx.lineTo(cx1 - rw1/2 - guardW1*0.5, y1);
    ctx.lineTo(cx1 - rw1/2 - guardW1*2, y1);
    ctx.closePath();
    ctx.fill();
    // å³
    ctx.beginPath();
    ctx.moveTo(cx0 + rw0/2 + guardW0*0.5, y0);
    ctx.lineTo(cx0 + rw0/2 + guardW0*2, y0);
    ctx.lineTo(cx1 + rw1/2 + guardW1*2, y1);
    ctx.lineTo(cx1 + rw1/2 + guardW1*0.5, y1);
    ctx.closePath();
    ctx.fill();

    // è·¯é¢
    const stripe = (Math.floor(dt0/24)%2===0);
    ctx.fillStyle = stripe ? 'rgba(98,98,98,0.94)' : 'rgba(88,88,88,0.94)';
    ctx.beginPath();
    ctx.moveTo(cx0 - rw0/2, y0);
    ctx.lineTo(cx0 + rw0/2, y0);
    ctx.lineTo(cx1 + rw1/2, y1);
    ctx.lineTo(cx1 - rw1/2, y1);
    ctx.closePath();
    ctx.fill();

    // ç¸çŸ³ï¼ˆèµ¤ç™½ï¼‰
    const curbW0 = Math.max(5, rw0*0.035);
    const curbW1 = Math.max(2, rw1*0.035);
    const curbStripe = (Math.floor(dt0/18)%2===0);
    ctx.fillStyle = curbStripe ? 'rgba(255,70,70,0.96)' : 'rgba(245,245,245,0.95)';
    // å·¦
    ctx.beginPath();
    ctx.moveTo(cx0 - rw0/2 - curbW0, y0);
    ctx.lineTo(cx0 - rw0/2, y0);
    ctx.lineTo(cx1 - rw1/2, y1);
    ctx.lineTo(cx1 - rw1/2 - curbW1, y1);
    ctx.closePath();
    ctx.fill();
    // å³
    ctx.beginPath();
    ctx.moveTo(cx0 + rw0/2, y0);
    ctx.lineTo(cx0 + rw0/2 + curbW0, y0);
    ctx.lineTo(cx1 + rw1/2 + curbW1, y1);
    ctx.lineTo(cx1 + rw1/2, y1);
    ctx.closePath();
    ctx.fill();

    // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ©ã‚¤ãƒ³
    if(i%3===0){
      ctx.fillStyle = 'rgba(255,255,255,0.64)';
      const lw0 = Math.max(2, rw0*0.012);
      const lw1 = Math.max(1, rw1*0.012);
      ctx.beginPath();
      ctx.moveTo(cx0 - lw0/2, y0);
      ctx.lineTo(cx0 + lw0/2, y0);
      ctx.lineTo(cx1 + lw1/2, y1);
      ctx.lineTo(cx1 - lw1/2, y1);
      ctx.closePath();
      ctx.fill();
    }
  }

  // éšœå®³ç‰©ï¼ˆå…ˆï¼‰
  const look = 280;
  const viewObs = obstacles.filter(o => !o.used && o.t >= t0 && o.t <= t0 + look);
  for(const ob of viewObs){
    const p = (ob.t - t0) / look;
    const y = lerp(baseY, horizon, p);
    const rw = lerp(roadWNear, roadWFar, p);
    const c = centerOffset(ob.t % LAP_LEN);
    const cx = w/2 + c * (w*0.26) * (1 - p*0.78);
    const x = cx + ob.x * (rw*0.40);
    const size = lerp(36, 14, p);
    const emoji = ob.kind === 'cone' ? 'ğŸš§' : 'ğŸŒ';
    drawText(x, y-10, emoji, size, 0.98);
  }

  // â˜…ã‚¢ã‚¤ãƒ†ãƒ ç®±ï¼ˆï¼Ÿï¼‰
  const viewBoxes = itemBoxes.filter(b => (b.t >= t0 && b.t <= t0 + look));
  for(const b of viewBoxes){
    const p = (b.t - t0) / look;
    if(p < 0 || p > 1) continue;
    const y = lerp(baseY, horizon, p);
    const rw = lerp(roadWNear, roadWFar, p);
    const c = centerOffset(b.t % LAP_LEN);
    const cx = w/2 + c * (w*0.26) * (1 - p*0.78);
    const x = cx + b.x * (rw*0.40);

    const size = lerp(34, 14, p);
    const alpha = b.cooldown > 0 ? 0.18 : 0.95;
    // ã‚­ãƒ©ãƒƒã¨æ„Ÿ
    drawText(x, y-12, 'â“', size, alpha);
    if(b.cooldown <= 0 && Math.random() < 0.08){
      drawText(x + rand(-6,6), y - 30 + rand(-6,6), 'âœ¨', Math.max(10, size*0.55), 0.5);
    }
  }

  // ã‚«ãƒ¼ãƒˆæç”»ï¼ˆé è¿‘ï¼‰
  const ranking = getRanking();
  for(const r of ranking.slice().reverse()){
    const rel = clamp((r.totalDist - t0) / 250, -0.25, 1.0);
    const p = clamp(rel, 0, 1);
    const y = lerp(baseY, horizon, p);
    const rw = lerp(roadWNear, roadWFar, p);
    const c = centerOffset((t0 + p*250) % LAP_LEN);
    const cx = w/2 + c * (w*0.26) * (1 - p*0.78);
    const x = cx + r.x * (rw*0.40);
    const size = r === me ? 46 : lerp(34, 16, p);

    drawText(x, y-10, r.kart, size, 1);

    // ãƒ©ãƒ™ãƒ«
    const lap = Math.min(gameState.totalLaps, Math.floor(r.totalDist / LAP_LEN) + 1);
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    const tw = size*1.45;
    const th = 18;
    ctx.beginPath();
    ctx.roundRect(x - tw/2, y + 14, tw, th, 10);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.font = `12px "Zen Maru Gothic", sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${r.char} L${lap}`, x, y + 23);
    ctx.restore();
  }
}

/* ===========================
   å½“ãŸã‚Šåˆ¤å®š
=========================== */
function handleObstacleCollision(){
  const me = gameState.player;
  const t0 = me.totalDist;
  for(const ob of obstacles){
    if(ob.used) continue;
    const d = ob.t - t0;
    if(d < -12) continue;
    if(d > 18) break;
    if(Math.abs(ob.x - me.x) < 0.14){
      ob.used = true;
      me.hits++; gameState.hits++;
      if(ob.kind === 'banana'){
        me.spin(0.7);
      }else{
        me.speed *= 0.55;
        me.vx *= -0.4;
      }
    }
  }
}

function handleBoxCollision(dt){
  const me = gameState.player;
  const t0 = me.totalDist;

  // cooldownæ¸›ã‚‰ã™ï¼ˆå…¨ç®±ï¼‰
  for(const b of itemBoxes){
    if(b.cooldown > 0) b.cooldown = Math.max(0, b.cooldown - dt);
  }

  // è¿‘ã„ç®±ã ã‘åˆ¤å®š
  for(const b of itemBoxes){
    const d = b.t - t0;
    if(d < -12) continue;
    if(d > 18) break;

    if(b.cooldown <= 0 && Math.abs(b.x - me.x) < 0.16){
      // â˜…å¿…ãšã‚¢ã‚¤ãƒ†ãƒ 
      me.giveItem();
      me.boxes++; gameState.boxes++;
      b.cooldown = BOX_RESPAWN;

      // ã¡ã‚‡ã„åŠ é€Ÿï¼ˆå–ã£ãŸæ„Ÿï¼‰
      me.boost(0.35, 0.08);

      itemDisplay.textContent = `GET! ${me.item}`;
      itemDisplay.classList.remove('shake'); void itemDisplay.offsetWidth; itemDisplay.classList.add('shake');
      setTimeout(()=> itemDisplay.textContent = me.item ? me.item : '---', 600);
    }
  }
}

/* ===========================
   HUD
=========================== */
function updateHUD(){
  const ranking = getRanking();
  const myPos = ranking.findIndex(p=>p===gameState.player)+1;
  posEl.textContent = myPos;

  const lap = Math.min(gameState.totalLaps, Math.floor(gameState.player.totalDist / LAP_LEN) + 1);
  lapTotalEl.textContent = gameState.totalLaps;
  lapDisplay.textContent = lap;

  speedEl.textContent = `${Math.round(gameState.player.speed * 220)}`;
  driftMeterEl.textContent = Math.round(gameState.player.drift*100);
  itemDisplay.textContent = gameState.player.item ? gameState.player.item : '---';
}

/* ===========================
   ã‚¢ã‚¤ãƒ†ãƒ 
=========================== */
function applyItem(item){
  const me = gameState.player;
  if(item === 'ğŸ„'){ me.boost(0.9, 0.16); return 'ğŸ„ ãƒ–ãƒ¼ã‚¹ãƒˆï¼'; }
  if(item === 'â­'){ me.boost(1.2, 0.22); return 'â­ ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ–ãƒ¼ã‚¹ãƒˆï¼'; }
  if(item === 'ğŸª¶'){ me.boost(0.6, 0.12); return 'ğŸª¶ ãµã‚ã£ã¨åŠ é€Ÿï¼'; }
  if(item === 'ğŸ¢'){
    const rank = getRanking();
    const idx = rank.findIndex(r=>r===me);
    if(idx>0){ rank[idx-1].spin(0.8); }
    return 'ğŸ¢ ã“ã†ã‚‰ï¼';
  }
  if(item === 'ğŸŒ'){
    obstacles.push({ t: me.totalDist + 90, x: clamp(me.x + rand(-0.15,0.15), -0.95, 0.95), kind:'banana', used:false });
    obstacles.sort((a,b)=>a.t-b.t);
    return 'ğŸŒ ãƒãƒŠãƒŠæŠ•ä¸‹ï¼';
  }
  if(item === 'ğŸ’£'){
    gameState.players.forEach(p=>{ if(p.isAI && Math.abs(p.totalDist-me.totalDist)<140) p.spin(0.45); });
    return 'ğŸ’£ ã©ã‹ãƒ¼ã‚“ï¼';
  }
  if(item === 'ğŸ¦‘'){
    me.spin(0.4);
    return 'ğŸ¦‘ ãã‚‰ãã‚‰â€¦';
  }
  if(item === 'ğŸ‘»'){
    me.boost(0.7, 0.14);
    return 'ğŸ‘» ã™ã‚ŠæŠœã‘æ°—åˆ†ï¼';
  }
  return 'ğŸ¯ ç™ºå‹•ï¼';
}

function handleItemUse(){
  if(!gameState.player || gameState.pausedByQuiz) return;

  if(!gameState.player.item){
    // â˜…ç®±ã‚’å–ã‚‹ã‚²ãƒ¼ãƒ ã«ã—ãŸã„ã®ã§ã€ã“ã“ã§ã¯â€œç„¡æ–™é…å¸ƒâ€ã—ãªã„
    itemDisplay.textContent = 'ç®±ï¼ˆâ“ï¼‰ã‚’å–ã£ã¦ã­ï¼';
    itemDisplay.classList.remove('shake'); void itemDisplay.offsetWidth; itemDisplay.classList.add('shake');
    setTimeout(()=> itemDisplay.textContent = gameState.player.item ? gameState.player.item : '---', 650);
    return;
  }
  const it = gameState.player.useItem();
  if(it){
    gameState.itemsUsed++;
    const msg = applyItem(it);
    itemDisplay.textContent = msg;
    itemDisplay.classList.remove('shake'); void itemDisplay.offsetWidth; itemDisplay.classList.add('shake');
    setTimeout(()=> itemDisplay.textContent = gameState.player.item ? gameState.player.item : '---', 700);
  }
}

/* ===========================
   ãƒ«ãƒ¼ãƒ—
=========================== */
let lastT = performance.now();
function loop(now){
  if(!gameState.gameActive) return;
  const dt = clamp((now-lastT)/1000, 0, 0.033);
  lastT = now;

  if(!gameState.pausedByQuiz){
    const me = gameState.player;
    const t = me.totalDist;
    const cc = centerOffset(t % LAP_LEN);
    const courseCenterX = cc;
    const ahead = getRanking().filter(r => r.totalDist > me.totalDist);

    for(const r of gameState.players){
      const aheadList = r.isAI ? ahead : [];
      r.update(dt, courseCenterX, aheadList);
    }

    handleObstacleCollision();
    handleBoxCollision(dt);

    const lapDone = Math.floor(me.totalDist / LAP_LEN);
    if(lapDone > gameState.quizLapTriggered && lapDone > 0 && lapDone < gameState.totalLaps){
      gameState.quizLapTriggered = lapDone;
      openQuiz(lapDone);
    }

    const finishedAll = gameState.players.every(p => p.totalDist >= gameState.totalLaps * LAP_LEN);
    if(finishedAll){
      endGame();
      return;
    }
  }

  updateHUD();
  draw();
  requestAnimationFrame(loop);
}

/* ===========================
   é–‹å§‹/çµ‚äº†
=========================== */
function startGame(){
  titleScreen.classList.add('hidden');
  resultScreen.classList.add('hidden');
  gameScreen.classList.remove('hidden');

  resizeCanvas();

  gameState.players = [];
  gameState.correctAnswers = 0;
  gameState.itemsUsed = 0;
  gameState.startTime = Date.now();
  gameState.pausedByQuiz = false;
  gameState.quizLapTriggered = -1;
  gameState.hits = 0;
  gameState.boxes = 0;

  buildObstacles(gameState.totalLaps);
  buildItemBoxes(gameState.totalLaps);

  const human = new Racer(gameState.selectedChar, gameState.selectedKart, false);
  gameState.player = human;
  gameState.players.push(human);

  const availC = characters.filter(c=>c!==gameState.selectedChar);
  const availK = karts.filter(k=>k!==gameState.selectedKart);
  for(let i=0;i<4;i++){
    const cpu = new Racer(availC[i%availC.length], availK[i%availK.length], true);
    cpu.x = rand(-0.35, 0.35);
    cpu.totalDist = rand(0, 30);
    gameState.players.push(cpu);
  }

  gameState.gameActive = true;
  lastT = performance.now();
  requestAnimationFrame(loop);
}

function endGame(){
  gameState.gameActive = false;
  gameScreen.classList.add('hidden');
  resultScreen.classList.remove('hidden');

  const ranking = getRanking();
  const myPos = ranking.findIndex(p=>p===gameState.player)+1;
  const medals = ['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰','4ï¸âƒ£','5ï¸âƒ£'];

  document.getElementById('result-position').textContent = medals[myPos-1] || 'ğŸ';
  document.getElementById('result-text').textContent = `${myPos}ä½ã§ã‚´ãƒ¼ãƒ«ï¼`;
  document.getElementById('correct-answers').textContent = gameState.correctAnswers;
  document.getElementById('items-used').textContent = gameState.itemsUsed;
  document.getElementById('hits').textContent = gameState.hits;
  document.getElementById('boxes').textContent = gameState.boxes;

  const timeSeconds = Math.round((Date.now() - gameState.startTime)/1000);
  const minutes = Math.floor(timeSeconds/60);
  const seconds = timeSeconds%60;
  document.getElementById('race-time').textContent = `${minutes}:${String(seconds).padStart(2,'0')}`;
}

/* ===========================
   é¸æŠUI
=========================== */
function initCharacterSelect(){
  const wrap = document.getElementById('char-select');
  wrap.innerHTML = '';
  characters.forEach((ch)=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='text-3xl p-2 rounded-lg bg-white/20 hover:bg-white/40 transition-all hover:scale-110 cursor-pointer';
    btn.textContent = ch;
    if(ch===gameState.selectedChar) btn.classList.add('ring-4','ring-yellow-300');
    btn.addEventListener('click', ()=>{
      gameState.selectedChar = ch;
      document.getElementById('selected-char').textContent = ch;
      document.querySelectorAll('#char-select button').forEach(b=>b.classList.remove('ring-4','ring-yellow-300'));
      btn.classList.add('ring-4','ring-yellow-300');
    });
    wrap.appendChild(btn);
  });
}
function initKartSelect(){
  const wrap = document.getElementById('kart-select');
  wrap.innerHTML = '';
  karts.forEach((k)=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='text-3xl p-2 rounded-lg bg-white/20 hover:bg-white/40 transition-all hover:scale-110 cursor-pointer';
    btn.textContent = k;
    if(k===gameState.selectedKart) btn.classList.add('ring-4','ring-pink-300');
    btn.addEventListener('click', ()=>{
      gameState.selectedKart = k;
      document.getElementById('selected-kart').textContent = k;
      document.querySelectorAll('#kart-select button').forEach(b=>b.classList.remove('ring-4','ring-pink-300'));
      btn.classList.add('ring-4','ring-pink-300');
    });
    wrap.appendChild(btn);
  });
}

/* ===========================
   ã‚¤ãƒ™ãƒ³ãƒˆ
=========================== */
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('retry-btn').addEventListener('click', ()=>{
  resultScreen.classList.add('hidden');
  titleScreen.classList.remove('hidden');
  gameState.gameActive = false;
  clearInterval(quizTimer);
  mathModal.classList.add('hidden');
});

document.getElementById('submit-answer').addEventListener('click', ()=>{
  const input = document.getElementById('math-answer');
  const v = Number(input.value);
  const fb = document.getElementById('math-feedback');

  if(Number.isNaN(v)){
    fb.textContent = 'æ•°å­—ã‚’å…¥ã‚Œã¦ã­ï¼';
    input.classList.remove('shake'); void input.offsetWidth; input.classList.add('shake');
    return;
  }
  if(v === currentQuiz.a){
    gameState.correctAnswers++;
    fb.textContent = 'âœ… æ­£è§£ï¼ãƒ–ãƒ¼ã‚¹ãƒˆï¼';
    closeQuizSuccess();
  }else{
    fb.textContent = 'âŒ ã¡ãŒã†ï¼ã‚‚ã†ä¸€å›ï¼';
    input.classList.remove('shake'); void input.offsetWidth; input.classList.add('shake');
    timeLeft = Math.max(1, timeLeft - 2);
    document.getElementById('time-left').textContent = timeLeft;
  }
});

/* ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ */
document.addEventListener('keydown', (e)=>{
  if(gameScreen.classList.contains('hidden')) return;

  if(!mathModal.classList.contains('hidden')){
    if(e.key === 'Enter'){ e.preventDefault(); document.getElementById('submit-answer').click(); }
    return;
  }

  if(e.key==='ArrowUp')    { e.preventDefault(); gameState.keys.up=true; }
  if(e.key==='ArrowDown')  { e.preventDefault(); gameState.keys.down=true; }
  if(e.key==='ArrowLeft')  { e.preventDefault(); gameState.keys.left=true; }
  if(e.key==='ArrowRight') { e.preventDefault(); gameState.keys.right=true; }
  if(e.key==='Shift')      { e.preventDefault(); gameState.keys.drift=true; }
  if(e.key===' ')          { e.preventDefault(); handleItemUse(); }
});
document.addEventListener('keyup', (e)=>{
  if(e.key==='ArrowUp') gameState.keys.up=false;
  if(e.key==='ArrowDown') gameState.keys.down=false;
  if(e.key==='ArrowLeft') gameState.keys.left=false;
  if(e.key==='ArrowRight') gameState.keys.right=false;
  if(e.key==='Shift') gameState.keys.drift=false;
});

/* pointeré•·æŠ¼ã— */
function bindHoldPointer(btnId, onDown, onUp){
  const el = document.getElementById(btnId);
  el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); el.setPointerCapture(e.pointerId); onDown(); });
  el.addEventListener('pointerup',   (e)=>{ e.preventDefault(); onUp(); });
  el.addEventListener('pointercancel',(e)=>{ e.preventDefault(); onUp(); });
  el.addEventListener('pointerleave', ()=>{ onUp(); });
}
bindHoldPointer('btn-accel', ()=>gameState.keys.up=true, ()=>gameState.keys.up=false);
bindHoldPointer('btn-brake', ()=>gameState.keys.down=true, ()=>gameState.keys.down=false);
bindHoldPointer('btn-left',  ()=>gameState.keys.left=true, ()=>gameState.keys.left=false);
bindHoldPointer('btn-right', ()=>gameState.keys.right=true,()=>gameState.keys.right=false);
bindHoldPointer('btn-drift', ()=>gameState.keys.drift=true,()=>gameState.keys.drift=false);
document.getElementById('btn-item').addEventListener('click', (e)=>{ e.preventDefault(); handleItemUse(); });

/* åˆæœŸåŒ– */
initCharacterSelect();
initKartSelect();
document.getElementById('selected-char').textContent = gameState.selectedChar;
document.getElementById('selected-kart').textContent = gameState.selectedKart;
</script>
</body>
</html>
