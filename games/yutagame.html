<!doctype html>
<html lang="ja" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ç®—æ•°ã‚«ãƒ¼ãƒˆãƒ¬ãƒ¼ã‚¹ v4</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700;900&display=swap');
    * { font-family: 'Zen Maru Gothic', sans-serif; }
    html, body { height: 100%; }
    body { margin: 0; background: #071022; }
    .track-gradient { background: linear-gradient(135deg, #0c1222 0%, #0b1b34 55%, #0d2d55 100%); }
    .press:active{ transform: scale(0.96); }

    #game-screen { height: 100vh; }
    #race-view{
      height: calc(100vh - 170px);
      min-height: 440px;
      position: relative;
      overflow: hidden;
      background: linear-gradient(180deg, #78c6ff 0%, #e5f7ff 45%, #7fe0a0 45%, #67b987 100%);
      touch-action: manipulation;
    }

    /* Canvasã¯çµ¶å¯¾å‰é¢ã§è¡¨ç¤º */
    #game-canvas{
      position:absolute; inset:0;
      width: 100%; height: 100%;
      z-index: 10;
    }

    #debug{
      position:absolute; left:10px; bottom:10px;
      z-index: 99;
      background: rgba(0,0,0,0.55);
      color:#fff; padding:8px 10px;
      border-radius: 12px;
      font-size: 12px;
      line-height: 1.35;
      pointer-events:none;
      backdrop-filter: blur(4px);
    }

    @keyframes shake { 0%,100%{ transform: translateX(0);} 25%{ transform: translateX(-6px);} 75%{ transform: translateX(6px);} }
    .shake { animation: shake 220ms ease-in-out; }

    .modal-card{
      box-shadow: 0 20px 80px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.18);
    }
  </style>
</head>

<body class="h-full overflow-auto">
<div id="app" class="h-full w-full track-gradient text-white">

  <!-- ã‚¿ã‚¤ãƒˆãƒ« -->
  <div id="title-screen" class="h-full flex flex-col items-center justify-center p-4">
    <h1 class="text-4xl md:text-6xl font-black text-yellow-300 mb-3 text-center drop-shadow-lg">
      ğŸï¸ ç®—æ•°ã‚«ãƒ¼ãƒˆãƒ¬ãƒ¼ã‚¹ ğŸï¸
    </h1>
    <p class="text-lg md:text-xl mb-6 text-cyan-200">ã‚«ãƒ¼ãƒ–ï¼†éšœå®³ç‰©ï¼ 1å‘¨ã”ã¨ã«ç®—æ•°ï¼</p>

    <div class="bg-white/10 backdrop-blur rounded-2xl p-5 mb-5 max-w-md w-full">
      <h2 class="text-xl font-bold mb-3 text-center text-yellow-200">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</h2>
      <div class="grid grid-cols-4 gap-3 mb-3" id="char-select"></div>
      <p class="text-center text-sm text-gray-200">é¸æŠä¸­: <span id="selected-char" class="text-2xl">ğŸ¥¸</span></p>
    </div>

    <div class="bg-white/10 backdrop-blur rounded-2xl p-5 mb-6 max-w-md w-full">
      <h2 class="text-xl font-bold mb-3 text-center text-pink-200">ã‚«ãƒ¼ãƒˆ</h2>
      <div class="grid grid-cols-4 gap-3 mb-3" id="kart-select"></div>
      <p class="text-center text-sm text-gray-200">é¸æŠä¸­: <span id="selected-kart" class="text-2xl">ğŸ¦</span></p>
    </div>

    <div class="text-center text-sm text-gray-300 mb-4">
      æ“ä½œï¼šâ†‘åŠ é€Ÿ / â†“ãƒ–ãƒ¬ãƒ¼ã‚­ / â†â†’ãƒãƒ³ãƒ‰ãƒ«(ç²¾å¯†) / Shiftãƒ‰ãƒªãƒ•ãƒˆ / Spaceã‚¢ã‚¤ãƒ†ãƒ 
    </div>

    <button id="start-btn"
      class="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white text-2xl font-black py-4 px-12 rounded-full shadow-lg transform hover:scale-105 transition-all press">
      ğŸš€ ãƒ¬ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ¼ãƒˆï¼
    </button>
  </div>

  <!-- ã‚²ãƒ¼ãƒ  -->
  <div id="game-screen" class="hidden flex-col">
    <!-- HUD -->
    <div class="bg-black/80 p-3 flex flex-wrap gap-2 justify-between items-center">
      <div class="text-base md:text-lg font-bold">
        <span class="text-white/60 mr-2">BUILD v4.0</span>
        ğŸ <span id="lap-display">1</span>/<span id="lap-total">10</span>å‘¨
        <span class="mx-2">|</span>
        ğŸ† <span id="position">1</span>ä½/5
      </div>

      <div class="flex flex-wrap gap-3 items-center text-sm md:text-base">
        <div>âš¡ <span id="player-speed">0</span></div>
        <div>ğŸŒ€ ãƒ‰ãƒªãƒ•ãƒˆ: <span id="drift-meter">0</span>%</div>
        <div>ğŸ <span id="item-display">---</span></div>
      </div>
    </div>

    <!-- ãƒ¬ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ -->
    <div id="race-view">
      <canvas id="game-canvas"></canvas>
      <div id="debug" class="hidden"></div>
    </div>

    <!-- æ“ä½œ -->
    <div class="bg-black/70 p-3">
      <div class="flex flex-wrap justify-center gap-3 mb-2">
        <button id="btn-left"  class="bg-slate-600 hover:bg-slate-700 px-5 py-2 rounded-lg font-bold press">â¬…ï¸ å·¦</button>
        <button id="btn-accel" class="bg-green-600 hover:bg-green-700 px-6 py-2 rounded-lg font-bold press">â¬†ï¸ ã‚¢ã‚¯ã‚»ãƒ«</button>
        <button id="btn-brake" class="bg-red-600 hover:bg-red-700 px-6 py-2 rounded-lg font-bold press">â¬‡ï¸ ãƒ–ãƒ¬ãƒ¼ã‚­</button>
        <button id="btn-right" class="bg-slate-600 hover:bg-slate-700 px-5 py-2 rounded-lg font-bold press">â¡ï¸ å³</button>
        <button id="btn-drift" class="bg-purple-600 hover:bg-purple-700 px-6 py-2 rounded-lg font-bold press">ğŸŒ€ ãƒ‰ãƒªãƒ•ãƒˆ</button>
        <button id="btn-item" class="bg-yellow-500 hover:bg-yellow-600 px-6 py-2 rounded-lg font-bold press">ğŸ¯ ã‚¢ã‚¤ãƒ†ãƒ </button>
      </div>
      <p class="text-center text-xs md:text-sm text-gray-300">
        â€»PCã¯ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ¨å¥¨ï¼šâ†â†’ã§ç²¾å¯†ãƒãƒ³ãƒ‰ãƒ« / Shiftã§ãƒ‰ãƒªãƒ•ãƒˆ / Spaceã§ã‚¢ã‚¤ãƒ†ãƒ 
      </p>
    </div>
  </div>

  <!-- ç®—æ•°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="math-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
    <div class="modal-card bg-gradient-to-br from-purple-600 to-indigo-700 rounded-3xl p-7 max-w-md w-full text-center">
      <h2 class="text-3xl font-black mb-3 text-yellow-200">ğŸ“š 1å‘¨ã‚¯ãƒªã‚¢ï¼ç®—æ•°ã‚¿ã‚¤ãƒ ï¼</h2>
      <p class="text-sm text-white/90 mb-2">æ­£è§£ã—ãªã„ã¨ãƒ¬ãƒ¼ã‚¹å†é–‹ã§ãã¾ã›ã‚“ã€‚</p>

      <div class="bg-white/15 rounded-2xl p-4 mb-4">
        <div class="text-sm text-white/80 mb-1">å•é¡Œ</div>
        <p id="math-question" class="text-4xl font-black">15 + 35 = ?</p>
      </div>

      <input type="number" id="math-answer"
        class="w-full text-3xl text-center p-4 rounded-xl bg-white text-gray-800 mb-3"
        placeholder="ç­”ãˆã‚’å…¥åŠ›" />

      <button id="submit-answer"
        class="bg-gradient-to-r from-green-500 to-emerald-600 text-white text-xl font-black py-3 px-8 rounded-full hover:scale-105 transition-transform w-full press">
        å›ç­”ã™ã‚‹ï¼
      </button>

      <div class="mt-4 text-sm text-gray-100">
        â° åˆ¶é™æ™‚é–“: <span id="time-left" class="font-black">10</span>ç§’
      </div>
      <p id="math-feedback" class="mt-3 text-sm font-bold text-yellow-200"></p>
    </div>
  </div>

  <!-- çµæœ -->
  <div id="result-screen" class="hidden h-full flex-col items-center justify-center p-4 bg-gradient-to-b from-purple-900 to-blue-900">
    <h1 class="text-5xl font-black mb-4">ğŸ ãƒ¬ãƒ¼ã‚¹çµ‚äº†ï¼ ğŸ</h1>
    <div id="result-position" class="text-8xl mb-4">ğŸ¥‡</div>
    <p id="result-text" class="text-3xl font-black text-yellow-300 mb-8">1ä½ã§ã‚´ãƒ¼ãƒ«ï¼</p>

    <div class="bg-white/10 backdrop-blur rounded-2xl p-6 mb-8 max-w-md w-full">
      <h3 class="text-xl font-black mb-4">ğŸ“Š ã‚¹ã‚¿ãƒƒãƒ„</h3>
      <p class="mb-2">æ­£è§£ã—ãŸå•é¡Œ: <span id="correct-answers" class="font-black">0</span>å•</p>
      <p class="mb-2">ä½¿ç”¨ã‚¢ã‚¤ãƒ†ãƒ : <span id="items-used" class="font-black">0</span>å€‹</p>
      <p>ãƒ¬ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ : <span id="race-time" class="font-black">0:00</span></p>
      <p class="mt-2 text-sm text-white/70">éšœå®³ç‰©ãƒ’ãƒƒãƒˆ: <span id="hits" class="font-black">0</span>å›</p>
    </div>

    <button id="retry-btn"
      class="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white text-2xl font-black py-4 px-12 rounded-full shadow-lg transform hover:scale-105 transition-all press">
      ğŸ”„ ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤
    </button>
  </div>

</div>

<script>
/* ===========================
   å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
=========================== */
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function rand(min,max){ return Math.random()*(max-min)+min; }
function randi(min,max){ return Math.floor(rand(min,max+1)); }

/* ===========================
   åˆæœŸãƒ‡ãƒ¼ã‚¿
=========================== */
const characters = ['ğŸ¥¸','ğŸ¥·ğŸ¿','ğŸ’€','ğŸ’°','ğŸœ','ğŸ°','ğŸ·','ğŸ¦‡'];
const karts      = ['ğŸ¦','ğŸ¦€','ğŸ„','ğŸ–','ğŸ›’','ğŸ“','ğŸœ','ğŸ‡'];
const itemsPool  = ['ğŸŒ','ğŸ„','â­','ğŸ’£','ğŸ¦‘','ğŸª¶','ğŸ¢','ğŸ‘»'];

const titleScreen  = document.getElementById('title-screen');
const gameScreen   = document.getElementById('game-screen');
const resultScreen = document.getElementById('result-screen');

const lapDisplay   = document.getElementById('lap-display');
const lapTotalEl   = document.getElementById('lap-total');
const posEl        = document.getElementById('position');
const speedEl      = document.getElementById('player-speed');
const driftMeterEl = document.getElementById('drift-meter');
const itemDisplay  = document.getElementById('item-display');

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d', { alpha: true });

/* ===========================
   ã‚³ãƒ¼ã‚¹ï¼ˆã‚«ãƒ¼ãƒ–ï¼‰
   centerOffset(t): -1..+1
   tã¯ã‚³ãƒ¼ã‚¹ä¸Šã®è·é›¢(0..LAP_LEN)
=========================== */
const LAP_LEN = 1000; // 1å‘¨ã®ã€Œè·é›¢ã€å˜ä½ï¼ˆå†…éƒ¨ï¼‰
function centerOffset(t){
  // å‘¨ã«ã‚ˆã£ã¦å¾®å¦™ã«é•ã†æ„Ÿï¼ˆtã«å‘¨æœŸã‚’è¤‡æ•°é‡ã­ã‚‹ï¼‰
  const a = Math.sin(t*0.008) * 0.55;
  const b = Math.sin(t*0.019 + 1.2) * 0.25;
  const c = Math.sin(t*0.041 + 2.1) * 0.12;
  return clamp(a+b+c, -0.95, 0.95);
}

/* ===========================
   éšœå®³ç‰©ï¼ˆè·é›¢tã¨æ¨ªä½ç½®x -1..1ï¼‰
=========================== */
let obstacles = [];
function buildObstacles(totalLaps){
  obstacles = [];
  for(let lap=0; lap<totalLaps; lap++){
    const base = lap * LAP_LEN;
    // 1å‘¨ã‚ãŸã‚Š 6ã€œ10å€‹
    const n = randi(6,10);
    for(let i=0;i<n;i++){
      const tt = base + randi(140, LAP_LEN-120);
      // ã‚³ãƒ¼ã‚¹ä¸­å¿ƒã‹ã‚‰å°‘ã—ã‚ºãƒ©ã™
      const off = centerOffset(tt % LAP_LEN);
      const x = clamp(off + rand(-0.55, 0.55), -0.95, 0.95);
      const kind = Math.random() < 0.6 ? 'cone' : 'banana';
      obstacles.push({ t: tt, x, kind, used:false });
    }
  }
  obstacles.sort((a,b)=>a.t-b.t);
}

/* ===========================
   ç®—æ•°ï¼ˆ1å‘¨ã”ã¨ï¼‰
=========================== */
const mathModal = document.getElementById('math-modal');
let quizTimer = null;
let timeLeft = 10;
let currentQuiz = { q:'', a:0 };

function makeMathProblem(lapIndex){
  const level = clamp(lapIndex, 1, 10);
  const types = level <= 3 ? ['add','sub'] : (level <= 6 ? ['add','sub','mul'] : ['add','sub','mul','mix']);
  const type = types[Math.floor(Math.random()*types.length)];
  const rr = (min,max)=> Math.floor(Math.random()*(max-min+1))+min;

  if(type==='add'){
    const a = rr(10*level, 25*level);
    const b = rr(5*level, 18*level);
    return { q: `${a} + ${b}`, a: a+b };
  }
  if(type==='sub'){
    let a = rr(15*level, 28*level);
    let b = rr(5*level, 20*level);
    if(b>a) [a,b] = [b,a];
    return { q: `${a} - ${b}`, a: a-b };
  }
  if(type==='mul'){
    const a = rr(2, Math.min(9, 2+Math.floor(level/2)));
    const b = rr(2, 9);
    return { q: `${a} Ã— ${b}`, a: a*b };
  }
  const a = rr(2, 9), b = rr(2, 9), c = rr(5, 30);
  return { q: `${a} Ã— ${b} + ${c}`, a: a*b + c };
}

function openQuiz(lapCompleted){
  gameState.pausedByQuiz = true;
  mathModal.classList.remove('hidden');

  currentQuiz = makeMathProblem(lapCompleted);
  document.getElementById('math-question').textContent = `${currentQuiz.q} = ?`;
  document.getElementById('math-answer').value = '';
  document.getElementById('math-feedback').textContent = '';

  clearInterval(quizTimer);
  timeLeft = 10;
  document.getElementById('time-left').textContent = timeLeft;

  quizTimer = setInterval(()=>{
    timeLeft--;
    document.getElementById('time-left').textContent = timeLeft;
    if(timeLeft <= 0){
      clearInterval(quizTimer);
      document.getElementById('math-feedback').textContent = 'â° ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼å°‘ã—æ¸›é€Ÿâ€¦ æ¬¡ã®å•é¡Œï¼';
      gameState.player.speed *= 0.55;
      setTimeout(()=> openQuiz(lapCompleted), 650);
    }
  }, 1000);

  setTimeout(()=> document.getElementById('math-answer').focus(), 50);
}

function closeQuizSuccess(){
  clearInterval(quizTimer);
  mathModal.classList.add('hidden');
  gameState.pausedByQuiz = false;
  // æ­£è§£ã§å°ãƒ–ãƒ¼ã‚¹ãƒˆ
  gameState.player.boost(0.9, 0.22);
}

/* ===========================
   ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼AI
=========================== */
class Racer {
  constructor(char, kart, isAI){
    this.char = char;
    this.kart = kart;
    this.isAI = isAI;

    this.totalDist = 0;     // ã‚³ãƒ¼ã‚¹ä¸Šã®é€²ã‚“ã è·é›¢ï¼ˆé †ä½ã«ç›´çµï¼‰
    this.speed = isAI ? rand(0.33, 0.42) : 0; // 0..1 ãã‚‰ã„ã®ã‚¹ã‚±ãƒ¼ãƒ«
    this.vx = 0;            // æ¨ªé€Ÿåº¦
    this.x = isAI ? rand(-0.25, 0.25) : 0; // -1..+1ï¼ˆé“è·¯å†…ï¼‰
    this.drift = 0;         // 0..1
    this.boostTime = 0;
    this.boostPower = 0;

    this.item = null;
    this.stun = 0;

    // AIæ€§æ ¼
    this.aiLineBias = isAI ? rand(-0.35, 0.35) : 0;
    this.aiTopSpeed = isAI ? rand(0.36, 0.44) : 0.45;
    this.aiAggro = isAI ? rand(0.6, 1.0) : 0;

    this.hits = 0;
  }

  giveItem(){
    this.item = itemsPool[randi(0, itemsPool.length-1)];
  }

  boost(sec, power){
    this.boostTime = Math.max(this.boostTime, sec);
    this.boostPower = Math.max(this.boostPower, power);
  }

  spin(sec){
    this.stun = Math.max(this.stun, sec);
    this.speed *= 0.35;
    this.vx *= -0.35;
  }

  useItem(){
    if(!this.item) return null;
    const it = this.item;
    this.item = null;
    return it;
  }

  update(dt, courseCenterX, roadHalfW, aheadList){
    // ã‚¹ã‚¿ãƒ³
    if(this.stun > 0){
      this.stun -= dt;
      this.speed = Math.max(0, this.speed - dt*0.25);
    }

    // ãƒ–ãƒ¼ã‚¹ãƒˆ
    if(this.boostTime > 0){
      this.boostTime -= dt;
    }

    if(this.isAI){
      // AIï¼šã‚³ãƒ¼ã‚¹ä¸­å¿ƒ + bias ã‚’ç‹™ã†ã€‚éšœå®³ç‰©ã‚’é¿ã‘ã‚‹ã€‚å‰èµ°è€…ã‚’é¿ã‘ã¦æŠœãã€‚
      let targetX = courseCenterX + this.aiLineBias;

      // è¿‘ã„éšœå®³ç‰©ã‚’å›é¿
      const lookAhead = 120;
      const myT = this.totalDist;
      for(const ob of obstacles){
        if(ob.used) continue;
        const d = ob.t - myT;
        if(d < 0) continue;
        if(d > lookAhead) break;
        // éšœå®³ç‰©ã®ä½ç½®ãŒè¿‘ã„ãªã‚‰ãšã‚‰ã™
        const ox = ob.x;
        const near = Math.abs(ox - this.x) < 0.18;
        if(near){
          targetX += (this.x < ox ? -0.35 : 0.35) * (1 - d/lookAhead);
        }
      }

      // å‰ã®ç›¸æ‰‹ã«è¿‘ã„ãªã‚‰ã€ãƒ©ã‚¤ãƒ³ã‚’å¤‰ãˆã¦æŠœã
      for(const a of aheadList){
        const dd = a.totalDist - this.totalDist;
        if(dd > 0 && dd < 80){
          const closeX = Math.abs(a.x - this.x) < 0.16;
          if(closeX){
            targetX += (this.x < a.x ? -0.28 : 0.28) * (1 - dd/80);
          }
        }
      }

      targetX = clamp(targetX, -0.95, 0.95);

      // æ¨ªæ–¹å‘ã«æ»‘ã‚‰ã‹ã«è¿½å¾“ï¼ˆç²¾å¯†ï¼‰
      const steer = clamp((targetX - this.x) * 4.2, -1.0, 1.0);
      this.vx += steer * dt * 1.9;
      this.vx *= (1 - dt*2.0);

      // é€Ÿåº¦ï¼šã‚´ãƒ ãƒãƒ³ãƒ‰ï¼ˆæœ€å¾Œå°¾ã»ã©ã¡ã‚‡ã„é€Ÿãï¼‰
      const rank = getRanking().findIndex(r => r === this) + 1;
      const rubber = clamp((6 - rank) * 0.012, 0, 0.06); // 5ä½ã¯+0.012â€¦ã¿ãŸã„ãª
      const targetSp = this.aiTopSpeed + rubber;

      // ã‚«ãƒ¼ãƒ–ãŒãã¤ã„ã¨å°‘ã—è½ã¨ã™ï¼ˆã‚³ãƒ¼ã‚¹ä¸­å¿ƒã‹ã‚‰é›¢ã‚Œã‚‹ã»ã©ä¸åˆ©ï¼‰
      const curvePenalty = Math.abs(this.x - courseCenterX) * 0.08;
      let sp = targetSp - curvePenalty;

      // ãŸã¾ã«ãƒ‰ãƒªãƒ•ãƒˆã£ã½ã„æ»‘ã‚Š
      if(Math.random() < 0.005 * this.aiAggro && sp > 0.34){
        this.boost(0.45, 0.07);
      }

      // åŠ é€Ÿ/æ¸›é€Ÿ
      const accel = 0.55;
      this.speed = lerp(this.speed, sp, 1 - Math.exp(-accel*dt));

      // ã‚¢ã‚¤ãƒ†ãƒ 
      if(!this.item && Math.random() < 0.008) this.giveItem();
      if(this.item && Math.random() < 0.004) {
        const it = this.useItem();
        // AIã¯ç°¡ç•¥ï¼šğŸ„â­ã ã‘è‡ªåˆ†å¼·åŒ–ã€ä»–ã¯å‰æ–¹å¦¨å®³
        if(it === 'ğŸ„') this.boost(0.7, 0.12);
        if(it === 'â­') this.boost(1.0, 0.18);
      }
    }else{
      // äººé–“ï¼šç²¾å¯†ãƒãƒ³ãƒ‰ãƒ«ï¼ˆé€£ç¶šå€¤ï¼‰
      const steering = (gameState.keys.right?1:0) - (gameState.keys.left?1:0);
      const accel = gameState.keys.up ? 0.62 : 0.0;
      const brake = gameState.keys.down ? 0.95 : 0.0;

      // ãƒ‰ãƒªãƒ•ãƒˆï¼šæ¨ªã®æ…£æ€§ã‚’å¢—ã‚„ã—ã¦æ»‘ã‚‹
      const drifting = gameState.keys.drift && Math.abs(steering) > 0 && this.speed > 0.18 && this.stun<=0;
      if(drifting){
        this.drift = clamp(this.drift + dt*0.55, 0, 1);
      }else{
        // ãƒ‰ãƒªãƒ•ãƒˆè§£é™¤æ™‚ã€æºœã‚ã«å¿œã˜ã¦ãƒŸãƒ‹ã‚¿ãƒ¼ãƒœ
        if(this.drift > 0.22){
          const pow = this.drift > 0.75 ? 0.18 : (this.drift > 0.5 ? 0.13 : 0.09);
          const sec = this.drift > 0.75 ? 1.0 : (this.drift > 0.5 ? 0.75 : 0.55);
          this.boost(sec, pow);
        }
        this.drift = 0;
      }

      // æ¨ªåŠ é€Ÿåº¦ï¼ˆãƒ‰ãƒªãƒ•ãƒˆä¸­ã¯æ»‘ã‚Šã‚„ã™ã„ï¼æ…£æ€§å¼·ã‚ï¼‰
      const steerPower = drifting ? 2.2 : 3.4;
      this.vx += steering * dt * steerPower;

      // æ¨ªæ‘©æ“¦ï¼ˆãƒ‰ãƒªãƒ•ãƒˆä¸­ã¯å¼±ãã—ã¦â€œæ»‘ã‚Šâ€ã‚’å‡ºã™ï¼‰
      const sideFric = drifting ? 0.55 : 0.85;
      this.vx *= (1 - dt * (2.6*sideFric));

      // é€Ÿåº¦
      const top = 0.46;
      const target = clamp(top + (this.boostTime>0 ? this.boostPower : 0) , 0, 0.62);

      // ã‚«ãƒ¼ãƒ–ã®å¤–å´ã‚’èµ°ã‚‹ã¨å°‘ã—è½ã¡ã‚‹ï¼ˆãƒ©ã‚¤ãƒ³å–ã‚Šé‡è¦ï¼‰
      const curvePenalty = Math.abs(this.x - courseCenterX) * 0.11;

      this.speed += accel * dt * 0.55;
      this.speed -= brake * dt * 0.85;
      this.speed -= dt * 0.22; // è‡ªç„¶æ¸›é€Ÿ
      this.speed = clamp(this.speed, 0, target - curvePenalty);

      // ã‚¢ã‚¤ãƒ†ãƒ 
      if(!this.item && Math.random() < 0.01) this.giveItem();
    }

    // ãƒ–ãƒ¼ã‚¹ãƒˆæ™‚é–“æ¸›
    if(this.boostTime > 0){
      this.boostTime -= dt;
      if(this.boostTime <= 0) this.boostPower = 0;
    }

    // æ¨ªä½ç½®æ›´æ–°ï¼ˆé“è·¯å†…ï¼‰
    this.x += this.vx * dt;
    this.x = clamp(this.x, -0.98, 0.98);

    // é€²è¡Œ
    // ã‚«ãƒ¼ãƒ–ä¸­ã¯å†…å´ãŒå°‘ã—æœ‰åˆ©ã€å¤–å´ã¯ä¸åˆ©ï¼ˆâ€œæŠœã‘ã‚‹â€ãŒèµ·ãã‚„ã™ã„ï¼‰
    const lineBonus = 1 - Math.abs(this.x - courseCenterX) * 0.06;
    const forward = this.speed * lineBonus;

    this.totalDist += forward * dt * 220; // é€²ã¿é‡ã®ä¿‚æ•°

    // å‘¨å›ãƒ»ã‚´ãƒ¼ãƒ«
    const lapNow = Math.floor(this.totalDist / LAP_LEN);
    if(lapNow >= gameState.totalLaps){
      this.totalDist = gameState.totalLaps * LAP_LEN;
      this.speed = 0;
    }
  }
}

/* ===========================
   ã‚²ãƒ¼ãƒ çŠ¶æ…‹
=========================== */
const gameState = {
  selectedChar: characters[0],
  selectedKart: karts[0],
  totalLaps: 10,
  players: [],
  player: null,
  keys: { up:false, down:false, left:false, right:false, drift:false },
  gameActive: false,
  pausedByQuiz: false,
  quizLapTriggered: -1,
  correctAnswers: 0,
  itemsUsed: 0,
  startTime: 0,
  hits: 0
};

function getRanking(){
  return [...gameState.players].sort((a,b)=> b.totalDist - a.totalDist);
}

/* ===========================
   Canvasã‚µã‚¤ã‚º
=========================== */
function resizeCanvas(){
  const rect = document.getElementById('race-view').getBoundingClientRect();
  canvas.width  = Math.floor(rect.width  * devicePixelRatio);
  canvas.height = Math.floor(rect.height * devicePixelRatio);
  canvas.style.width  = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resizeCanvas);

/* ===========================
   æç”»ï¼ˆç°¡æ˜“OutRuné¢¨ï¼šæ‰‹å‰ãŒåºƒã„ï¼‰
=========================== */
function drawText(x,y,text,size=22,alpha=1,shadow=true){
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.font = `${size}px "Zen Maru Gothic", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  if(shadow){
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetY = 4;
  }
  ctx.fillText(text, x, y);
  ctx.restore();
}

function draw(){
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  ctx.clearRect(0,0,w,h);

  // åœ°é¢ï¼ˆç°¡æ˜“ï¼‰
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.fillRect(0, h*0.45, w, h*0.55);

  // è¦–ç‚¹
  const horizon = h*0.18;
  const baseY = h*0.92;

  // è‡ªåˆ†ã®è·é›¢ã‚’åŸºæº–ã«ã€Œå…ˆã®é“ã€ã‚’æã
  const me = gameState.player;
  const t0 = me.totalDist;

  // é“ã®å¹…ï¼ˆæ‰‹å‰åºƒãã€å¥¥ç‹­ã„ï¼‰
  const roadWNear = w*0.72;
  const roadWFar  = w*0.12;

  // é“ã‚’åˆ†å‰²ã—ã¦æã
  const segments = 70;
  for(let i=segments; i>=1; i--){
    const p0 = (i-1)/segments;
    const p1 = i/segments;

    // è·é›¢ï¼ˆå¥¥ã»ã©å…ˆï¼‰
    const dt0 = t0 + p0*260;
    const dt1 = t0 + p1*260;

    const c0 = centerOffset(dt0 % LAP_LEN);
    const c1 = centerOffset(dt1 % LAP_LEN);

    // é“ä¸­å¿ƒ
    const cx0 = w/2 + c0 * (w*0.22) * (1 - p0*0.75);
    const cx1 = w/2 + c1 * (w*0.22) * (1 - p1*0.75);

    // é“å¹…
    const rw0 = lerp(roadWNear, roadWFar, p0);
    const rw1 = lerp(roadWNear, roadWFar, p1);

    // yï¼ˆé è¿‘ï¼‰
    const y0 = lerp(baseY, horizon, p0);
    const y1 = lerp(baseY, horizon, p1);

    // è·¯é¢ã®è‰²ï¼ˆã‚¹ãƒˆãƒ©ã‚¤ãƒ—ï¼‰
    const stripe = (Math.floor((dt0)/24) % 2 === 0);
    ctx.fillStyle = stripe ? 'rgba(95,95,95,0.92)' : 'rgba(86,86,86,0.92)';

    ctx.beginPath();
    ctx.moveTo(cx0 - rw0/2, y0);
    ctx.lineTo(cx0 + rw0/2, y0);
    ctx.lineTo(cx1 + rw1/2, y1);
    ctx.lineTo(cx1 - rw1/2, y1);
    ctx.closePath();
    ctx.fill();

    // è·¯è‚©ï¼ˆé»„é»’ï¼‰
    const edgeW0 = Math.max(6, rw0*0.04);
    const edgeW1 = Math.max(2, rw1*0.04);

    const edgeStripe = (Math.floor(dt0/18) % 2 === 0);
    ctx.fillStyle = edgeStripe ? 'rgba(255,208,0,0.95)' : 'rgba(20,20,20,0.95)';

    // å·¦
    ctx.beginPath();
    ctx.moveTo(cx0 - rw0/2 - edgeW0, y0);
    ctx.lineTo(cx0 - rw0/2, y0);
    ctx.lineTo(cx1 - rw1/2, y1);
    ctx.lineTo(cx1 - rw1/2 - edgeW1, y1);
    ctx.closePath();
    ctx.fill();
    // å³
    ctx.beginPath();
    ctx.moveTo(cx0 + rw0/2, y0);
    ctx.lineTo(cx0 + rw0/2 + edgeW0, y0);
    ctx.lineTo(cx1 + rw1/2 + edgeW1, y1);
    ctx.lineTo(cx1 + rw1/2, y1);
    ctx.closePath();
    ctx.fill();

    // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ©ã‚¤ãƒ³
    if(i%3===0){
      ctx.fillStyle = 'rgba(255,255,255,0.65)';
      const lw0 = Math.max(2, rw0*0.012);
      const lw1 = Math.max(1, rw1*0.012);
      ctx.beginPath();
      ctx.moveTo(cx0 - lw0/2, y0);
      ctx.lineTo(cx0 + lw0/2, y0);
      ctx.lineTo(cx1 + lw1/2, y1);
      ctx.lineTo(cx1 - lw1/2, y1);
      ctx.closePath();
      ctx.fill();
    }
  }

  // éšœå®³ç‰©æç”»ï¼ˆè‡ªåˆ†ã®å°‘ã—å…ˆã ã‘ï¼‰
  const look = 260;
  const viewObs = obstacles.filter(o => !o.used && o.t >= t0 && o.t <= t0 + look);
  for(const ob of viewObs){
    const p = (ob.t - t0) / look; // 0..1
    const y = lerp(baseY, horizon, p);
    const rw = lerp(roadWNear, roadWFar, p);
    const c = centerOffset(ob.t % LAP_LEN);
    const cx = w/2 + c * (w*0.22) * (1 - p*0.75);
    const x = cx + ob.x * (rw*0.40);

    const size = lerp(34, 14, p);
    const emoji = ob.kind === 'cone' ? 'ğŸš§' : 'ğŸŒ';
    drawText(x, y-8, emoji, size, 0.95, true);
  }

  // ãƒ©ãƒ³ã‚­ãƒ³ã‚°é †ã«æç”»ï¼ˆé ã„=ä¸Šã«å°ã•ãï¼‰
  const ranking = getRanking();
  for(const r of ranking.slice().reverse()){
    // rãŒè‡ªåˆ†ã‚ˆã‚Šå…ˆãªã‚‰ä¸Šã®æ–¹ã€é…ã„ãªã‚‰ä¸‹ã®æ–¹
    const rel = clamp((r.totalDist - t0) / 240, -0.25, 1.0);
    const p = clamp(rel, 0, 1);

    const y = lerp(baseY, horizon, p);
    const rw = lerp(roadWNear, roadWFar, p);
    const c = centerOffset((t0 + p*240) % LAP_LEN);
    const cx = w/2 + c * (w*0.22) * (1 - p*0.75);

    const x = cx + r.x * (rw*0.40);
    const size = r === me ? 44 : lerp(34, 16, p);

    // ã‚«ãƒ¼ãƒˆ
    drawText(x, y-10, r.kart, size, 1, true);

    // ãƒ©ãƒ™ãƒ«ï¼ˆã¡ã‚‡ã„ä¸‹ï¼‰
    const lap = Math.min(gameState.totalLaps, Math.floor(r.totalDist / LAP_LEN) + 1);
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    const tw = size*1.4;
    const th = 18;
    ctx.beginPath();
    ctx.roundRect(x - tw/2, y + 14, tw, th, 10);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.font = `12px "Zen Maru Gothic", sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${r.char} L${lap}`, x, y + 23);
    ctx.restore();
  }
}

/* ===========================
   è¡çªåˆ¤å®šï¼ˆéšœå®³ç‰©ï¼‰
=========================== */
function handleCollisions(){
  const me = gameState.player;
  const t0 = me.totalDist;
  // è¿‘ã„éšœå®³ç‰©ã ã‘è¦‹ã‚‹
  for(const ob of obstacles){
    if(ob.used) continue;
    const d = ob.t - t0;
    if(d < -12) continue;
    if(d > 18) break; // è¿‘ãã ã‘
    // æ¨ªã‚‚è¿‘ã‘ã‚Œã°ãƒ’ãƒƒãƒˆ
    if(Math.abs(ob.x - me.x) < 0.14){
      ob.used = true;
      me.hits++;
      gameState.hits++;
      // ç¨®é¡ã§åŠ¹æœ
      if(ob.kind === 'banana'){
        me.spin(0.7);
      }else{
        me.speed *= 0.55;
        me.vx *= -0.4;
      }
    }
  }
}

/* ===========================
   HUD
=========================== */
function updateHUD(){
  const ranking = getRanking();
  const myPos = ranking.findIndex(p=>p===gameState.player)+1;
  posEl.textContent = myPos;

  const lap = Math.min(gameState.totalLaps, Math.floor(gameState.player.totalDist / LAP_LEN) + 1);
  lapTotalEl.textContent = gameState.totalLaps;
  lapDisplay.textContent = lap;

  const sp = Math.round(gameState.player.speed * 220); // ãã‚Œã£ã½ã„è¡¨ç¤º
  speedEl.textContent = `${sp}`;

  driftMeterEl.textContent = Math.round(gameState.player.drift*100);

  itemDisplay.textContent = gameState.player.item ? gameState.player.item : '---';
}

/* ===========================
   ã‚¢ã‚¤ãƒ†ãƒ 
=========================== */
function applyItem(item){
  const me = gameState.player;
  if(item === 'ğŸ„'){ me.boost(0.9, 0.16); return 'ğŸ„ ãƒ–ãƒ¼ã‚¹ãƒˆï¼'; }
  if(item === 'â­'){ me.boost(1.2, 0.22); return 'â­ ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ–ãƒ¼ã‚¹ãƒˆï¼'; }
  if(item === 'ğŸª¶'){ me.boost(0.6, 0.12); return 'ğŸª¶ ãµã‚ã£ã¨åŠ é€Ÿï¼'; }
  if(item === 'ğŸ¢'){
    // å‰ã®ç›¸æ‰‹ã‚’ã‚¹ãƒ”ãƒ³
    const rank = getRanking();
    const idx = rank.findIndex(r=>r===me);
    if(idx>0){ rank[idx-1].spin(0.8); }
    return 'ğŸ¢ ã“ã†ã‚‰ï¼';
  }
  if(item === 'ğŸŒ'){
    // ã™ãå‰æ–¹ã«ãƒãƒŠãƒŠè¿½åŠ 
    obstacles.push({ t: me.totalDist + 90, x: clamp(me.x + rand(-0.15,0.15), -0.95, 0.95), kind:'banana', used:false });
    obstacles.sort((a,b)=>a.t-b.t);
    return 'ğŸŒ ãƒãƒŠãƒŠæŠ•ä¸‹ï¼';
  }
  if(item === 'ğŸ’£'){
    // å‘¨å›²ã®AIå°‘ã—æ¸›é€Ÿ
    gameState.players.forEach(p=>{ if(p.isAI && Math.abs(p.totalDist-me.totalDist)<140) p.spin(0.45); });
    return 'ğŸ’£ ã©ã‹ãƒ¼ã‚“ï¼';
  }
  if(item === 'ğŸ¦‘'){
    me.spin(0.4);
    return 'ğŸ¦‘ ãã‚‰ãã‚‰â€¦';
  }
  if(item === 'ğŸ‘»'){
    me.boost(0.7, 0.14);
    return 'ğŸ‘» ã™ã‚ŠæŠœã‘æ°—åˆ†ï¼';
  }
  return 'ğŸ¯ ç™ºå‹•ï¼';
}

function handleItemUse(){
  if(!gameState.player || gameState.pausedByQuiz) return;

  if(!gameState.player.item){
    gameState.player.giveItem();
    return;
  }
  const it = gameState.player.useItem();
  if(it){
    gameState.itemsUsed++;
    const msg = applyItem(it);
    itemDisplay.textContent = msg;
    itemDisplay.classList.remove('shake'); void itemDisplay.offsetWidth; itemDisplay.classList.add('shake');
    setTimeout(()=> itemDisplay.textContent = gameState.player.item ? gameState.player.item : '---', 700);
  }
}

/* ===========================
   ãƒ«ãƒ¼ãƒ—
=========================== */
let lastT = performance.now();
function loop(now){
  if(!gameState.gameActive) return;

  const dt = clamp((now-lastT)/1000, 0, 0.033);
  lastT = now;

  if(!gameState.pausedByQuiz){
    const me = gameState.player;
    const t = me.totalDist;
    const cc = centerOffset(t % LAP_LEN); // -1..1
    const courseCenterX = cc; // ãã®ã¾ã¾ä½¿ã†ï¼ˆ-1..1ï¼‰
    const ahead = getRanking().filter(r => r.totalDist > me.totalDist);

    // æ›´æ–°
    for(const r of gameState.players){
      const aheadList = r.isAI ? ahead : [];
      r.update(dt, courseCenterX, 1, aheadList);
    }

    // éšœå®³ç‰©å½“ãŸã‚Šåˆ¤å®š
    handleCollisions();

    // 1å‘¨ã”ã¨ç®—æ•°ï¼ˆæœ€çµ‚å‘¨ã¯å‡ºã•ãªã„ï¼‰
    const lapDone = Math.floor(me.totalDist / LAP_LEN);
    if(lapDone > gameState.quizLapTriggered && lapDone > 0 && lapDone < gameState.totalLaps){
      gameState.quizLapTriggered = lapDone;
      openQuiz(lapDone);
    }

    // ã‚´ãƒ¼ãƒ«åˆ¤å®šï¼ˆå…¨å“¡ãŒç·è·é›¢ã«é”ã—ãŸã‚‰ï¼‰
    const finishedAll = gameState.players.every(p => p.totalDist >= gameState.totalLaps * LAP_LEN);
    if(finishedAll){
      endGame();
      return;
    }
  }

  updateHUD();
  draw();
  requestAnimationFrame(loop);
}

/* ===========================
   é–‹å§‹/çµ‚äº†
=========================== */
function startGame(){
  titleScreen.classList.add('hidden');
  resultScreen.classList.add('hidden');
  gameScreen.classList.remove('hidden');

  resizeCanvas();

  gameState.players = [];
  gameState.correctAnswers = 0;
  gameState.itemsUsed = 0;
  gameState.startTime = Date.now();
  gameState.pausedByQuiz = false;
  gameState.quizLapTriggered = -1;
  gameState.hits = 0;

  // éšœå®³ç‰©ç”Ÿæˆ
  buildObstacles(gameState.totalLaps);

  // äººé–“
  const human = new Racer(gameState.selectedChar, gameState.selectedKart, false);
  gameState.player = human;
  gameState.players.push(human);

  // CPU 4
  const availC = characters.filter(c=>c!==gameState.selectedChar);
  const availK = karts.filter(k=>k!==gameState.selectedKart);
  for(let i=0;i<4;i++){
    const cpu = new Racer(availC[i%availC.length], availK[i%availK.length], true);
    cpu.x = rand(-0.35, 0.35);
    cpu.totalDist = rand(0, 30); // å°‘ã—æ•£ã‚‰ã™
    gameState.players.push(cpu);
  }

  gameState.gameActive = true;
  lastT = performance.now();
  requestAnimationFrame(loop);
}

function endGame(){
  gameState.gameActive = false;
  gameScreen.classList.add('hidden');
  resultScreen.classList.remove('hidden');

  const ranking = getRanking();
  const myPos = ranking.findIndex(p=>p===gameState.player)+1;
  const medals = ['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰','4ï¸âƒ£','5ï¸âƒ£'];

  document.getElementById('result-position').textContent = medals[myPos-1] || 'ğŸ';
  document.getElementById('result-text').textContent = `${myPos}ä½ã§ã‚´ãƒ¼ãƒ«ï¼`;
  document.getElementById('correct-answers').textContent = gameState.correctAnswers;
  document.getElementById('items-used').textContent = gameState.itemsUsed;
  document.getElementById('hits').textContent = gameState.hits;

  const timeSeconds = Math.round((Date.now() - gameState.startTime)/1000);
  const minutes = Math.floor(timeSeconds/60);
  const seconds = timeSeconds%60;
  document.getElementById('race-time').textContent = `${minutes}:${String(seconds).padStart(2,'0')}`;
}

/* ===========================
   é¸æŠUI
=========================== */
function initCharacterSelect(){
  const wrap = document.getElementById('char-select');
  wrap.innerHTML = '';
  characters.forEach((ch)=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='text-3xl p-2 rounded-lg bg-white/20 hover:bg-white/40 transition-all hover:scale-110 cursor-pointer';
    btn.textContent = ch;
    if(ch===gameState.selectedChar) btn.classList.add('ring-4','ring-yellow-300');
    btn.addEventListener('click', ()=>{
      gameState.selectedChar = ch;
      document.getElementById('selected-char').textContent = ch;
      document.querySelectorAll('#char-select button').forEach(b=>b.classList.remove('ring-4','ring-yellow-300'));
      btn.classList.add('ring-4','ring-yellow-300');
    });
    wrap.appendChild(btn);
  });
}

function initKartSelect(){
  const wrap = document.getElementById('kart-select');
  wrap.innerHTML = '';
  karts.forEach((k)=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='text-3xl p-2 rounded-lg bg-white/20 hover:bg-white/40 transition-all hover:scale-110 cursor-pointer';
    btn.textContent = k;
    if(k===gameState.selectedKart) btn.classList.add('ring-4','ring-pink-300');
    btn.addEventListener('click', ()=>{
      gameState.selectedKart = k;
      document.getElementById('selected-kart').textContent = k;
      document.querySelectorAll('#kart-select button').forEach(b=>b.classList.remove('ring-4','ring-pink-300'));
      btn.classList.add('ring-4','ring-pink-300');
    });
    wrap.appendChild(btn);
  });
}

/* ===========================
   ã‚¤ãƒ™ãƒ³ãƒˆ
=========================== */
document.getElementById('start-btn').addEventListener('click', startGame);

document.getElementById('retry-btn').addEventListener('click', ()=>{
  resultScreen.classList.add('hidden');
  titleScreen.classList.remove('hidden');
  gameState.gameActive = false;
  clearInterval(quizTimer);
  mathModal.classList.add('hidden');
});

document.getElementById('submit-answer').addEventListener('click', ()=>{
  const input = document.getElementById('math-answer');
  const v = Number(input.value);
  const fb = document.getElementById('math-feedback');

  if(Number.isNaN(v)){
    fb.textContent = 'æ•°å­—ã‚’å…¥ã‚Œã¦ã­ï¼';
    input.classList.remove('shake'); void input.offsetWidth; input.classList.add('shake');
    return;
  }
  if(v === currentQuiz.a){
    gameState.correctAnswers++;
    fb.textContent = 'âœ… æ­£è§£ï¼ãƒ–ãƒ¼ã‚¹ãƒˆï¼';
    closeQuizSuccess();
  }else{
    fb.textContent = 'âŒ ã¡ãŒã†ï¼ã‚‚ã†ä¸€å›ï¼';
    input.classList.remove('shake'); void input.offsetWidth; input.classList.add('shake');
    timeLeft = Math.max(1, timeLeft - 2);
    document.getElementById('time-left').textContent = timeLeft;
  }
});

/* ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ */
document.addEventListener('keydown', (e)=>{
  if(gameScreen.classList.contains('hidden')) return;

  if(!mathModal.classList.contains('hidden')){
    if(e.key === 'Enter'){ e.preventDefault(); document.getElementById('submit-answer').click(); }
    return;
  }

  if(e.key==='ArrowUp')    { e.preventDefault(); gameState.keys.up=true; }
  if(e.key==='ArrowDown')  { e.preventDefault(); gameState.keys.down=true; }
  if(e.key==='ArrowLeft')  { e.preventDefault(); gameState.keys.left=true; }
  if(e.key==='ArrowRight') { e.preventDefault(); gameState.keys.right=true; }
  if(e.key==='Shift')      { e.preventDefault(); gameState.keys.drift=true; }
  if(e.key===' ')          { e.preventDefault(); handleItemUse(); }
});
document.addEventListener('keyup', (e)=>{
  if(e.key==='ArrowUp') gameState.keys.up=false;
  if(e.key==='ArrowDown') gameState.keys.down=false;
  if(e.key==='ArrowLeft') gameState.keys.left=false;
  if(e.key==='ArrowRight') gameState.keys.right=false;
  if(e.key==='Shift') gameState.keys.drift=false;
});

/* pointeré•·æŠ¼ã— */
function bindHoldPointer(btnId, onDown, onUp){
  const el = document.getElementById(btnId);
  el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); el.setPointerCapture(e.pointerId); onDown(); });
  el.addEventListener('pointerup',   (e)=>{ e.preventDefault(); onUp(); });
  el.addEventListener('pointercancel',(e)=>{ e.preventDefault(); onUp(); });
  el.addEventListener('pointerleave', ()=>{ onUp(); });
}
bindHoldPointer('btn-accel', ()=>gameState.keys.up=true, ()=>gameState.keys.up=false);
bindHoldPointer('btn-brake', ()=>gameState.keys.down=true, ()=>gameState.keys.down=false);
bindHoldPointer('btn-left',  ()=>gameState.keys.left=true, ()=>gameState.keys.left=false);
bindHoldPointer('btn-right', ()=>gameState.keys.right=true,()=>gameState.keys.right=false);
bindHoldPointer('btn-drift', ()=>gameState.keys.drift=true,()=>gameState.keys.drift=false);
document.getElementById('btn-item').addEventListener('click', (e)=>{ e.preventDefault(); handleItemUse(); });

/* åˆæœŸåŒ– */
initCharacterSelect();
initKartSelect();
document.getElementById('selected-char').textContent = gameState.selectedChar;
document.getElementById('selected-kart').textContent = gameState.selectedKart;
</script>
</body>
</html>
