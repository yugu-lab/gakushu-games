<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>タイピングバトル - 学習ゲーム</title>
    <link href="https://fonts.googleapis.com/css2?family=BIZ+UDGothic:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* 安全領域（iPad/iPhoneノッチ） */
        :root{
            --safe-top: env(safe-area-inset-top);
            --safe-right: env(safe-area-inset-right);
            --safe-bottom: env(safe-area-inset-bottom);
            --safe-left: env(safe-area-inset-left);
        }

        body {
            font-family: 'BIZ UDGothic', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
            user-select: none;
        }

        .game-container {
            width: 100vw;
            height: calc(var(--vh, 1vh) * 100);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* トップバー：左右にHP、中央にターン/タイマー */
        .top-bar{
            min-height: 80px;
            padding: calc(8px + var(--safe-top)) clamp(12px, 2vw, 24px) 8px clamp(12px, 2vw, 24px);
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255,255,255,0.2);

            /* Grid で左右端に固定 */
            display: grid;
            grid-template-columns: 1fr auto 1fr; /* 左 HP | 中央 info | 右 HP */
            align-items: center;
            gap: 12px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
            min-width: 0;          /* 端に寄せるため最小幅制約を外す */
            justify-self: start;   /* 左側は左端へ */
        }

        .player-info:last-child{
            justify-self: end;     /* 右側は右端へ */
            flex-direction: row-reverse; /* アイコンを右寄せのままにする */
        }

        .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .player-stats {
            flex: 1;
        }

        .player-name {
            font-weight: 700;
            color: white;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .hp-bar-container {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .center-info {
            text-align: center;
            color: white;
            justify-self: center;
        }

        .turn-display {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .phase-display {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 10px;
        }

        .timer-ring {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: conic-gradient(#feca57 0deg, rgba(255, 255, 255, 0.2) 0deg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: white;
            margin: 0 auto;
        }

        /* カードエリア */
        .card-area {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative;
        }

        /* プレイヤーの手札エリア（左右に配置） */
        .player-hand {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 100px;
            height: 400px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }

        .player-hand.left {
            left: 5px;
        }

        .player-hand.right {
            right: 5px;
        }

        .hand-card {
            width: 90px;
            height: 70px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 6px;
            text-align: center;
            font-size: 11px;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            transform: translateX(10px);
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .hand-card:hover {
            transform: translateX(0);
            opacity: 1;
        }

        /* メインカード表示エリア */
        .main-cards-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            padding: 0 130px; /* 左右の手札エリアを避けるための余白 */
        }

        .cards-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            max-width: 800px;
            margin: 0 auto;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.5s ease;
        }

        .cards-container.active {
            opacity: 1;
            transform: translateY(0);
        }

        .card {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            backdrop-filter: blur(15px);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            min-height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        /* 攻撃カード（デフォルト） */
        .card.attack {
            background: linear-gradient(145deg, rgba(255, 107, 107, 0.3), rgba(255, 159, 243, 0.2));
            border: 3px solid rgba(255, 107, 107, 0.5);
            box-shadow: 0 8px 32px rgba(255, 107, 107, 0.2);
        }

        .card.attack:hover {
            border-color: rgba(255, 107, 107, 0.8);
            box-shadow: 0 20px 40px rgba(255, 107, 107, 0.3);
        }

        /* 回復カード */
        .card.heal {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.3), rgba(129, 199, 132, 0.2));
            border: 3px solid rgba(76, 175, 80, 0.6);
            box-shadow: 0 8px 32px rgba(76, 175, 80, 0.2);
        }

        .card.heal:hover {
            border-color: rgba(76, 175, 80, 0.9);
            box-shadow: 0 20px 40px rgba(76, 175, 80, 0.4);
        }

        .card.heal .card-text {
            color: #e8f5e8;
        }

        .card.heal .card-difficulty {
            color: #a5d6a7;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .card:hover::before {
            transform: translateX(100%);
        }

        .card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            border-color: rgba(254, 202, 87, 0.6);
        }

        .card.selected {
            border-color: #feca57;
            box-shadow: 0 0 30px rgba(254, 202, 87, 0.8);
            transform: scale(1.1) translateY(-15px);
            background: linear-gradient(145deg, rgba(254, 202, 87, 0.3), rgba(255, 159, 243, 0.2));
            animation: cardSelect 0.6s ease;
        }

        @keyframes cardSelect {
            0% { transform: scale(1) translateY(0); }
            50% { transform: scale(1.15) translateY(-20px) rotateY(10deg); }
            100% { transform: scale(1.1) translateY(-15px); }
        }

        .card-text {
            font-size: 24px;
            font-weight: 700;
            color: white;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.05em;
            line-height: 1.2;
            word-break: keep-all;
            overflow-wrap: break-word;
            white-space: normal;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            max-height: 60px;
            overflow: hidden;
        }

        /* 文字数に応じたテキストサイズ調整（改行なしで統一レイアウト） */
        .card-text.short { font-size: 26px; }      /* 1-3文字 */
        .card-text.medium { font-size: 22px; }     /* 4-6文字 */
        .card-text.long { font-size: 18px; }       /* 7-9文字 */
        .card-text.very-long { font-size: 15px; }  /* 10-12文字 */
        .card-text.extra-long { font-size: 12px; } /* 13文字以上 */

        .card-difficulty {
            font-size: 14px;
            color: #feca57;
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            margin-bottom: 5px;
        }

        .card-category {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* タイピング表示エリア */
        .typing-display {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px 20px calc(20px + var(--safe-bottom)) 20px;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            max-width: 600px;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 15px auto;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            width: 0%;
            transition: width 0.2s ease;
        }

        .keyboard-hint {
            margin-top: 15px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-family: 'BIZ UDGothic', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #feca57, #ff9ff3);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* コントロールエリア */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* モーダル */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .modal p {
            color: #666;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        /* ダメージエフェクト */
        .damage-number {
            position: absolute;
            font-size: 32px;
            font-weight: 900;
            color: #ff6b6b;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 100;
            animation: damageFloat 1.5s ease-out forwards;
        }

        .damage-number.heal {
            color: #4ecdc4;
        }

        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(0.5);
            }
            20% {
                transform: translateY(-10px) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(0.8);
            }
        }

        /* ダメージ計算ポップアップ */
        .damage-calculation-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            pointer-events: none;
            animation: calculationPopup 5s ease-out forwards;
        }

        .calculation-content {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px 35px;
            text-align: center;
            border: 3px solid;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            min-width: 300px;
        }

        .calculation-content.attack {
            border-color: #ff6b6b;
            box-shadow: 0 10px 40px rgba(255, 107, 107, 0.3), 0 0 30px rgba(255, 107, 107, 0.2);
        }

        .calculation-content.heal {
            border-color: #4ecdc4;
            box-shadow: 0 10px 40px rgba(76, 224, 196, 0.3), 0 0 30px rgba(76, 224, 196, 0.2);
        }

        .calculation-content.self-damage {
            border-color: #ff9f43;
            box-shadow: 0 10px 40px rgba(255, 159, 67, 0.3), 0 0 30px rgba(255, 159, 67, 0.2);
        }

        .calculation-icon {
            font-size: 40px;
            margin-bottom: 15px;
            animation: iconBounce 0.6s ease-out;
        }

        .calculation-formula {
            font-size: 24px;
            font-weight: 900;
            color: white;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-family: 'BIZ UDGothic', sans-serif;
        }

        .calculation-description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 600;
        }

        @keyframes calculationPopup {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3) rotateY(-90deg);
            }
            7.5% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1) rotateY(0deg);
            }
            12.5% {
                transform: translate(-50%, -50%) scale(0.95) rotateY(0deg);
            }
            87.5% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotateY(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.1) rotateY(90deg);
            }
        }

        @keyframes iconBounce {
            0% {
                transform: scale(0.3) translateY(20px);
            }
            50% {
                transform: scale(1.2) translateY(-10px);
            }
            100% {
                transform: scale(1) translateY(0);
            }
        }

        /* ターン切り替えポップアップ */
        .turn-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.9));
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: turnPopup 2.5s ease-in-out forwards;
        }

        .turn-popup-content {
            text-align: center;
            color: white;
            transform: scale(0.5);
            animation: turnContentPop 2.5s ease-in-out forwards;
        }

        .turn-popup h2 {
            font-size: clamp(48px, 8vw, 120px);
            font-weight: 900;
            color: white;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5);
            margin: 0 0 20px 0;
            background: linear-gradient(45deg, #feca57, #ff9ff3, #4ecdc4);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: textGlow 2.5s ease-in-out infinite;
        }

        .turn-popup-subtitle {
            font-size: clamp(24px, 4vw, 48px);
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin: 0;
        }

        @keyframes turnPopup {
            0% {
                opacity: 0;
            }
            15% {
                opacity: 1;
            }
            85% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        @keyframes turnContentPop {
            0% {
                transform: scale(0.3) rotateY(-90deg);
                opacity: 0;
            }
            20% {
                transform: scale(1.2) rotateY(0deg);
                opacity: 1;
            }
            30% {
                transform: scale(0.95) rotateY(0deg);
                opacity: 1;
            }
            80% {
                transform: scale(1) rotateY(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(1.1) rotateY(90deg);
                opacity: 0;
            }
        }

        @keyframes textGlow {
            0%, 100% {
                filter: drop-shadow(0 0 20px rgba(254, 202, 87, 0.5));
            }
            50% {
                filter: drop-shadow(0 0 40px rgba(254, 202, 87, 0.8)) drop-shadow(0 0 60px rgba(255, 159, 243, 0.6));
            }
        }

        /* 属性カラー */
        .fire { --attr-color: #ff6b6b; }
        .water { --attr-color: #4ecdc4; }
        .thunder { --attr-color: #ffe66d; }
        .wind { --attr-color: #95e1d3; }
        .earth { --attr-color: #a8e6cf; }
        .light { --attr-color: #ffd93d; }

        /* エフェクトレイヤー */
        .fx-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        }

        /* 攻撃アニメーション用スタイル */
        .charge-effect {
            position: absolute;
            border-radius: 50%;
            will-change: transform, opacity;
            contain: layout paint;
        }

        .projectile {
            position: absolute;
            will-change: transform, opacity;
            contain: layout paint;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            will-change: transform, opacity;
            contain: layout paint;
        }

        .impact-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            will-change: opacity;
        }

        /* 強いシェイクアニメーション */
        .shake-strong {
            animation: shakeStrong 0.4s ease-in-out;
        }

        @keyframes shakeStrong {
            0%, 100% { transform: translate3d(0, 0, 0); }
            10% { transform: translate3d(-8px, -4px, 0); }
            20% { transform: translate3d(6px, -8px, 0); }
            30% { transform: translate3d(-6px, 4px, 0); }
            40% { transform: translate3d(8px, 6px, 0); }
            50% { transform: translate3d(-4px, -6px, 0); }
            60% { transform: translate3d(6px, 8px, 0); }
            70% { transform: translate3d(-8px, -2px, 0); }
            80% { transform: translate3d(4px, -8px, 0); }
            90% { transform: translate3d(-6px, 6px, 0); }
        }

        /* 溜めエフェクト */
        @keyframes chargeGlow {
            0% { 
                transform: scale(1);
                box-shadow: 0 0 10px var(--glow-color);
            }
            50% { 
                transform: scale(1.15);
                box-shadow: 0 0 30px var(--glow-color), 0 0 60px var(--glow-color);
            }
            100% { 
                transform: scale(1.2);
                box-shadow: 0 0 40px var(--glow-color), 0 0 80px var(--glow-color);
            }
        }

        /* 火球アニメーション */
        @keyframes fireball {
            0% { 
                transform: scale(0.5) rotate(0deg);
                opacity: 1;
            }
            100% { 
                transform: scale(1.2) rotate(360deg);
                opacity: 0.8;
            }
        }

        /* 水刃アニメーション */
        @keyframes waterBlade {
            0% { 
                transform: scaleX(0) rotate(-15deg);
                opacity: 1;
            }
            100% { 
                transform: scaleX(1) rotate(15deg);
                opacity: 0.9;
            }
        }

        /* 雷アニメーション */
        @keyframes lightning {
            0%, 100% { opacity: 0; }
            10%, 30%, 50%, 70%, 90% { opacity: 1; }
            20%, 40%, 60%, 80% { opacity: 0.3; }
        }

        /* 風刃アニメーション */
        @keyframes windBlade {
            0% { 
                transform: scale(0) rotate(0deg);
                opacity: 0.8;
            }
            100% { 
                transform: scale(1.5) rotate(180deg);
                opacity: 0.3;
            }
        }

        /* 岩柱アニメーション */
        @keyframes rockSpike {
            0% { 
                transform: scaleY(0) translateY(50px);
                opacity: 1;
            }
            100% { 
                transform: scaleY(1) translateY(0);
                opacity: 0.9;
            }
        }

        /* 光線アニメーション */
        @keyframes lightBeam {
            0% { 
                transform: scaleX(0);
                opacity: 1;
            }
            50% { 
                transform: scaleX(1);
                opacity: 1;
            }
            100% { 
                transform: scaleX(1.2);
                opacity: 0.7;
            }
        }

        /* パーティクル爆発 */
        @keyframes particleExplode {
            0% { 
                transform: scale(0) translate3d(0, 0, 0);
                opacity: 1;
            }
            100% { 
                transform: scale(1) translate3d(var(--dx), var(--dy), 0);
                opacity: 0;
            }
        }

        /* リップル効果 */
        @keyframes ripple {
            0% { 
                transform: scale(0);
                opacity: 0.8;
            }
            100% { 
                transform: scale(3);
                opacity: 0;
            }
        }

        /* ルーレット演出 */
        .roulette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }

        .roulette-container {
            text-align: center;
            color: white;
            position: relative;
        }

        .roulette-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .roulette-wheel {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(90deg, #ff6b6b 50%, #4ecdc4 50%);
            border: 6px solid #feca57;
            position: relative;
            margin: 0 auto 30px auto;
            box-shadow: 0 0 30px rgba(254, 202, 87, 0.5);
        }

        .roulette-pointer {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 24px solid #feca57;
            z-index: 10;
        }

        .roulette-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background: #feca57;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border: 3px solid white;
            z-index: 5;
        }

        .player-info-simple {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 400px;
            margin: 0 auto 20px auto;
            gap: 40px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px 20px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            min-width: 140px;
        }

        .player-card.left {
            border-color: #ff6b6b;
        }

        .player-card.right {
            border-color: #4ecdc4;
        }

        .player-avatar-simple {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .player-name-simple {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .player-side {
            font-size: 12px;
            opacity: 0.8;
        }

        .roulette-spinning {
            animation: rouletteSpin 2s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        .roulette-result {
            font-size: 20px;
            font-weight: 700;
            margin-top: 15px;
            opacity: 0;
            animation: resultFadeIn 0.5s ease-out 2.2s forwards;
        }

        @keyframes rouletteSpin {
            0% { transform: rotate(0deg); }
            70% { transform: rotate(1080deg); }
            100% { transform: rotate(var(--final-rotation, 1170deg)); }
        }

        @keyframes resultFadeIn {
            from { 
                opacity: 0;
                transform: translateY(20px) scale(0.8);
            }
            to { 
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* アクセシビリティ対応 */
        @media (prefers-reduced-motion: reduce) {
            .shake-strong {
                animation: none;
            }
            
            .impact-flash {
                opacity: 0.3 !important;
            }
            
            @keyframes shakeStrong {
                0%, 100% { transform: translate3d(0, 0, 0); }
            }

            .roulette-spinning {
                animation: rouletteSpinReduced 1s ease-out forwards;
            }

            @keyframes rouletteSpinReduced {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(var(--final-rotation, 180deg)); }
            }
        }

        /* レスポンシブ調整 */
        @media (max-width: 1024px) {
            .cards-container {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .main-cards-area {
                padding: 0 110px; /* タブレット用に余白を少し縮小 */
            }
        }

        @media (max-width: 768px) {
            .cards-container {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .main-cards-area {
                padding: 0 80px; /* スマホ用に余白をさらに縮小 */
            }
            
            .top-bar {
                height: 60px;
                padding: 0 10px;
            }
            
            .player-info {
                min-width: 200px;
            }
            
            .hp-bar-container {
                width: 150px;
            }

            .player-setup-container {
                flex-direction: column;
                gap: 20px;
            }

            .character-selection {
                grid-template-columns: repeat(6, 1fr);
                max-width: 100%;
            }
        }

        @media (max-width: 480px) {
            .main-cards-area {
                padding: 0 60px; /* 小さなスマホ用にさらに縮小 */
            }
            
            .player-hand {
                width: 80px; /* 手札カードも小さく */
            }
            
            .hand-card {
                width: 70px;
                height: 60px;
                font-size: 10px;
            }
        }

        .hidden {
            display: none !important;
        }

        .shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* 問題テキストの上下間隔も微調整 */
        .typing-guide {
            text-align: center;
            color: white;
            margin-bottom: 10px;
            user-select: none;
        }
        .typing-guide .jp {
            font-size: 32px;
            line-height: 1.1;
            letter-spacing: .06em;
            font-weight: 700;
        }
        @media (min-width: 1024px){ .typing-guide .jp { font-size: 40px; } }

        .typing-guide .sub {
            font-size: 14px;
            opacity: .9;
            margin-top: 6px;
            letter-spacing: .08em;
        }

        /* 上段：左から色が満ちる（文字単位じゃなく"面"でスーッと） */
        .jp-progress {
            display: inline-block;
            background: linear-gradient(
                90deg,
                #feca57 var(--fill, 0%),
                rgba(255,255,255,.95) var(--fill, 0%)
            );
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            transition: background .12s linear;
        }

        /* 下段：1文字ずつ点灯 */
        .sub .char { padding: 0 .06em; transition: color .08s, transform .04s; }
        .sub .char.matched { color: #feca57; }
        .sub .char.current { border-bottom: 2px solid #feca57; }
        .sub .char.pending { color: rgba(255,255,255,.85); opacity: .75; }

        /* ローマ字ガイド */
        .romaji-guide {
            text-align: center;
            color: white;
            margin-bottom: 8px;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 0.1em;
            min-height: 40px;
        }

        .romaji-char {
            display: inline-block;
            padding: 0 2px;
            transition: color 0.1s ease;
        }

        .romaji-char.typed {
            color: #feca57;
        }

        .romaji-char.current {
            background: rgba(254, 202, 87, 0.3);
            border-radius: 4px;
        }

        /* カウントダウン */
        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }

        .countdown-number {
            font-size: 120px;
            font-weight: 900;
            color: #feca57;
            text-shadow: 0 0 30px rgba(254, 202, 87, 0.5);
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* ゲーム開始画面 */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(var(--vh, 1vh) * 100);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .start-content {
            text-align: center;
            color: white;
        }

        .start-content h1 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .mode-selection {
            display: flex;
            gap: 40px;
            margin-bottom: 25px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 15px 35px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
            text-align: center;
            font-size: 16px;
            font-family: 'BIZ UDGothic', sans-serif;
            outline: none;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .mode-btn.selected {
            background: rgba(254, 202, 87, 0.3);
            border-color: #feca57;
            box-shadow: 0 0 30px rgba(254, 202, 87, 0.5);
        }

        .mode-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .mode-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .mode-desc {
            font-size: 12px;
            opacity: 0.8;
        }

        .player-setup-container {
            display: flex;
            gap: 50px;
            justify-content: center;
            align-items: flex-start;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .player-setup {
            flex: 1;
            max-width: 350px;
            min-width: 300px;
            text-align: center;
        }

        .character-selection {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
            max-width: 280px;
            margin-left: auto;
            margin-right: auto;
        }

        .character-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
        }

        .character-btn.selected {
            border-color: #feca57;
            box-shadow: 0 0 20px rgba(254, 202, 87, 0.5);
        }

        .name-input {
            width: 280px;
            height: 45px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 22px;
            padding: 0 20px;
            font-size: 17px;
            font-family: 'BIZ UDGothic', sans-serif;
            background: rgba(255, 255, 255, 0.9);
            outline: none;
            margin-bottom: 20px;
            text-align: center;
        }

        .name-input:focus {
            border-color: #feca57;
            box-shadow: 0 0 10px rgba(254, 202, 87, 0.3);
        }

        .rules-content {
            text-align: left;
            max-width: 500px;
            margin: 0 auto;
        }

        .rule-item {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .rule-icon {
            font-size: 24px;
            min-width: 40px;
        }

        .rule-text h4 {
            margin: 0 0 5px 0;
            font-size: 16px;
            color: #feca57;
        }

        .rule-text p {
            margin: 0;
            line-height: 1.4;
            font-size: 14px;
        }

        .hp-btn {
            padding: 12px 25px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 18px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 140px;
            text-align: center;
            font-family: 'BIZ UDGothic', sans-serif;
            font-size: 15px;
            font-weight: 600;
        }

        .hp-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .hp-btn.selected {
            background: rgba(254, 202, 87, 0.3);
            border-color: #feca57;
            box-shadow: 0 0 25px rgba(254, 202, 87, 0.4);
        }
    </style>
</head>
<body>
    <!-- ゲーム開始画面 -->
    <div class="start-screen" id="startScreen">
        <div class="start-content">
            <h1>⚔️ タイピングバトル</h1>
            <p style="font-size: 16px; margin-bottom: 20px;">学習しながら楽しくタイピング！</p>
            
            <div class="mode-selection">
                <button type="button" class="mode-btn" id="cpuModeBtn" onclick="selectMode('cpu')">
                    <div class="mode-icon">🤖</div>
                    <div class="mode-title">CPU戦</div>
                    <div class="mode-desc">コンピューターと対戦</div>
                </button>
                <button type="button" class="mode-btn" id="pvpModeBtn" onclick="selectMode('pvp')">
                    <div class="mode-icon">👥</div>
                    <div class="mode-title">2人対戦</div>
                    <div class="mode-desc">友達と一緒に対戦</div>
                </button>
            </div>

            <div id="characterSelection" class="hidden">
                <div class="hp-selection" style="margin-bottom: 25px;">
                    <h3 style="margin-bottom: 15px; font-size: 18px; color: white;">⚡ 初期HP設定</h3>
                    <div class="hp-options" style="display: flex; gap: 25px; justify-content: center; flex-wrap: wrap;">
                        <button class="hp-btn" data-hp="100" onclick="selectHP(100)">
                            <div style="font-size: 18px; margin-bottom: 4px;">💚</div>
                            <div style="font-size: 16px; font-weight: 700;">100HP</div>
                            <div style="font-size: 12px; opacity: 0.8;">短期決戦</div>
                        </button>
                        <button class="hp-btn selected" data-hp="200" onclick="selectHP(200)">
                            <div style="font-size: 18px; margin-bottom: 4px;">💛</div>
                            <div style="font-size: 16px; font-weight: 700;">200HP</div>
                            <div style="font-size: 12px; opacity: 0.8;">標準</div>
                        </button>
                        <button class="hp-btn" data-hp="300" onclick="selectHP(300)">
                            <div style="font-size: 18px; margin-bottom: 4px;">❤️</div>
                            <div style="font-size: 16px; font-weight: 700;">300HP</div>
                            <div style="font-size: 12px; opacity: 0.8;">長期戦</div>
                        </button>
                    </div>
                </div>

                <div class="player-setup-container">
                    <div id="player1Setup" class="player-setup">
                        <h3 style="margin-bottom: 15px; font-size: 18px;">プレイヤー1の設定</h3>
                        <input type="text" id="player1NameInput" class="name-input" value="プレイヤー1" placeholder="名前を入力">
                        <div class="character-selection">
                            <div class="character-btn fire" data-attr="fire" data-player="1" onclick="selectCharacter('fire', 1)">🔥</div>
                            <div class="character-btn water" data-attr="water" data-player="1" onclick="selectCharacter('water', 1)">💧</div>
                            <div class="character-btn thunder" data-attr="thunder" data-player="1" onclick="selectCharacter('thunder', 1)">⚡</div>
                            <div class="character-btn wind" data-attr="wind" data-player="1" onclick="selectCharacter('wind', 1)">🌪️</div>
                            <div class="character-btn earth" data-attr="earth" data-player="1" onclick="selectCharacter('earth', 1)">🌱</div>
                            <div class="character-btn light" data-attr="light" data-player="1" onclick="selectCharacter('light', 1)">✨</div>
                        </div>
                    </div>
                    
                    <div id="player2Setup" class="player-setup hidden">
                        <h3 style="margin-bottom: 15px; font-size: 18px;">プレイヤー2の設定</h3>
                        <input type="text" id="player2NameInput" class="name-input" value="プレイヤー2" placeholder="名前を入力">
                        <div class="character-selection">
                            <div class="character-btn fire" data-attr="fire" data-player="2" onclick="selectCharacter('fire', 2)">🔥</div>
                            <div class="character-btn water" data-attr="water" data-player="2" onclick="selectCharacter('water', 2)">💧</div>
                            <div class="character-btn thunder" data-attr="thunder" data-player="2" onclick="selectCharacter('thunder', 2)">⚡</div>
                            <div class="character-btn wind" data-attr="wind" data-player="2" onclick="selectCharacter('wind', 2)">🌪️</div>
                            <div class="character-btn earth" data-attr="earth" data-player="2" onclick="selectCharacter('earth', 2)">🌱</div>
                            <div class="character-btn light" data-attr="light" data-player="2" onclick="selectCharacter('light', 2)">✨</div>
                        </div>
                    </div>
                </div>
                
                <button class="btn btn-primary" id="nextBtn" onclick="showGameRules()" style="margin-top: 15px;" disabled>ゲームの遊び方を見る</button>
            </div>
            
            <div id="gameRules" class="hidden">
                <h2 style="margin-bottom: 20px; font-size: 22px;">📖 ゲームの遊び方</h2>
                <div class="rules-content">
                    <div class="rule-item">
                        <div class="rule-icon">⚔️</div>
                        <div class="rule-text">
                            <h4>基本ルール</h4>
                            <p>設定したHPでスタート。相手のHPを0にしたら勝利！</p>
                        </div>
                    </div>
                    <div class="rule-item">
                        <div class="rule-icon">📝</div>
                        <div class="rule-text">
                            <h4>タイピング</h4>
                            <p>手札から1枚選んで12秒以内にローマ字で入力</p>
                        </div>
                    </div>
                    <div class="rule-item">
                        <div class="rule-icon">💥</div>
                        <div class="rule-text">
                            <h4>ダメージ</h4>
                            <p>成功：文字数×残り時間でダメージ<br>失敗：文字数×5の自傷ダメージ<br>打ち間違え：2秒ペナルティ</p>
                        </div>
                    </div>
                </div>
                <button class="btn btn-primary" onclick="startGame()" style="margin-top: 20px; font-size: 16px; padding: 12px 30px;">🎮 ゲーム開始！</button>
            </div>

            <div style="margin-top: 20px; font-size: 12px; opacity: 0.8;">
                <p>📱 iPad横向きで最適化されています</p>
                <p>⌨️ ローマ字で入力してください（全角でもOK／長音はハイフン「-」）</p>
            </div>
        </div>
    </div>

    <!-- メインゲーム画面 -->
    <div class="game-container hidden" id="gameContainer">
        <!-- トップバー -->
        <div class="top-bar">
            <div class="player-info">
                <div class="avatar" id="player1Avatar">🔥</div>
                <div class="player-stats">
                    <div class="player-name" id="player1Name">プレイヤー1</div>
                    <div class="hp-bar-container">
                        <div class="hp-bar" id="player1HpBar" style="width: 100%;"></div>
                        <div class="hp-text" id="player1HpText">300/300</div>
                    </div>
                </div>
            </div>

            <div class="center-info">
                <div class="turn-display" id="turnDisplay" role="status" aria-live="polite">プレイヤー1のターン</div>
                <div class="phase-display" id="phaseDisplay" role="status" aria-live="polite">カードを選択してください</div>
                <div class="timer-ring" id="timerRing" role="progressbar" aria-valuemin="0" aria-valuemax="12" aria-live="polite">12</div>
            </div>

            <div class="player-info">
                <div class="avatar" id="player2Avatar">🤖</div>
                <div class="player-stats" style="text-align: right;">
                    <div class="player-name" id="player2Name">CPU</div>
                    <div class="hp-bar-container">
                        <div class="hp-bar" id="player2HpBar" style="width: 100%;"></div>
                        <div class="hp-text" id="player2HpText">300/300</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- カードエリア -->
        <div class="card-area">
            <!-- メインカード選択エリア -->
            <div class="main-cards-area">
                <div class="cards-container" id="cardsContainer">
                    <!-- カードは動的生成 -->
                </div>
            </div>
        </div>

        <!-- タイピングガイド表示エリア -->
        <div class="typing-display">
            <div id="typingGuide" class="typing-guide">
                <div id="typingGuideJP" class="jp jp-progress"></div>
                <div id="typingGuideSub" class="sub"></div>
            </div>
            <div id="romajiGuide" class="romaji-guide" aria-live="polite"></div>
            <div class="progress-bar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="keyboard-hint">
                <p>⌨️ キーボードで直接入力 | 長音は「-」| ESCキーでギブアップ</p>
            </div>
        </div>

        <!-- コントロール -->
        <div class="controls">
            <button class="control-btn" onclick="showHelp()" title="ヘルプ" aria-label="ヘルプ">❓</button>
            <button class="control-btn" onclick="toggleSound()" title="音量" aria-label="音量" id="soundBtn">🔊</button>
            <button class="control-btn" onclick="pauseGame()" title="一時停止" aria-label="一時停止" id="pauseBtn">⏸️</button>
            <button class="control-btn" onclick="backToMenu()" title="メニューに戻る" aria-label="メニューに戻る">🏠</button>
        </div>
    </div>

    <!-- モーダル -->
    <div class="modal" id="modal">
        <div class="modal-content" id="modalContent">
            <!-- 動的コンテンツ -->
        </div>
    </div>

    <script>
        // iPad/Safari 100vh問題対応
        function setVh() {
            document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
        }
        window.addEventListener('resize', setVh);
        setVh();

        // 変換中フラグ（IME）
        let isComposing = false;

        // 共通オーディオコンテキスト
        let audioCtx = null;
        function ensureAudio() {
            if (!audioCtx) {
                const Ctx = window.AudioContext || window.webkitAudioContext;
                audioCtx = new Ctx();
            }
        }
        document.addEventListener('pointerdown', () => {
            try {
                ensureAudio();
                audioCtx.resume();
            } catch (e) {}
        }, { once: true, passive: true });

        // IMEハンドラー関数（名前付きで重複登録を防ぐ）
        function handleCompositionStart() {
            isComposing = true;
        }

        function handleCompositionEnd() {
            setTimeout(() => { isComposing = false; }, 0);
        }

        // タイピングハンドラーの付け外しラッパー関数
        function enableTyping() {
            disableTyping(); // 先に外す（二重登録防止）
            document.addEventListener('keydown', handleKeyPress);
            document.addEventListener('compositionstart', handleCompositionStart);
            document.addEventListener('compositionend', handleCompositionEnd);
        }

        function disableTyping() {
            document.removeEventListener('keydown', handleKeyPress);
            document.removeEventListener('compositionstart', handleCompositionStart);
            document.removeEventListener('compositionend', handleCompositionEnd);
        }

        // 改良された日本語処理関数
        function toHiragana(s){
            if(!s) return '';
            let t = s.normalize('NFKC');
            // カタカナ→ひらがな
            t = t.replace(/[\u30A1-\u30FA\u30FD-\u30FF]/g, ch =>
                String.fromCharCode(ch.charCodeAt(0) - 0x60)
            );
            // 記号・空白除去
            t = t.replace(/[、。，．・！!？?\s（）()［］\[\]「」『』]/g,'');
            return t;
        }

        // ダメージ計算用：小文字を大文字化して概算長さに（ゃゅょ→や等／っ→つ）
        function countForDamage(s){
            const h = toHiragana(s)
                .replace(/[ぁァ]/g,'あ').replace(/[ぃィ]/g,'い').replace(/[ぅゥ]/g,'う')
                .replace(/[ぇェ]/g,'え').replace(/[ぉォ]/g,'お')
                .replace(/ゃ/g,'や').replace(/ゅ/g,'ゆ').replace(/ょ/g,'よ')
                .replace(/っ/g,'つ'); // 長音も1文字としてカウント
            return h.length;
        }

        // 正規化後の文字数を使う（ダメージ/自傷/統計はこれで統一）
        const countChars = (s) => countForDamage(s);

        /* =========================================================
           ローマ字：複数表記対応（促音/拗音/ん/代替表記）
        ========================================================= */


        // 拡張ベース文字
        const BASE = {
            'あ':['a'],'い':['i'],'う':['u'],'え':['e'],'お':['o'],
            'か':['ka'],'き':['ki'],'く':['ku'],'け':['ke'],'こ':['ko'],
            'が':['ga'],'ぎ':['gi'],'ぐ':['gu'],'げ':['ge'],'ご':['go'],
            'さ':['sa'],'し':['shi','si'],'す':['su'],'せ':['se'],'そ':['so'],
            'ざ':['za'],'じ':['ji','zi'],'ず':['zu'],'ぜ':['ze'],'ぞ':['zo'],
            'た':['ta'],'ち':['chi','ti'],'つ':['tsu','tu'],'て':['te'],'と':['to'],
            'だ':['da'],'ぢ':['ji','di'],'づ':['zu','du'],'で':['de'],'ど':['do'],
            'な':['na'],'に':['ni'],'ぬ':['nu'],'ね':['ne'],'の':['no'],
            'は':['ha'],'ひ':['hi'],'ふ':['fu','hu'],'へ':['he'],'ほ':['ho'],
            'ば':['ba'],'び':['bi'],'ぶ':['bu'],'べ':['be'],'ぼ':['bo'],
            'ぱ':['pa'],'ぴ':['pi'],'ぷ':['pu'],'ぺ':['pe'],'ぽ':['po'],
            'ま':['ma'],'み':['mi'],'む':['mu'],'め':['me'],'も':['mo'],
            'や':['ya'],'ゆ':['yu'],'よ':['yo'],
            'ら':['ra'],'り':['ri'],'る':['ru'],'れ':['re'],'ろ':['ro'],
            'わ':['wa'],'ゐ':['wi'],'ゑ':['we'],'を':['wo','o'],
            'ん':['n','nn'],
            'ぁ':['xa','la','a'],'ぃ':['xi','li','i'],'ぅ':['xu','lu','u'],'ぇ':['xe','le','e'],'ぉ':['xo','lo','o'],
            'っ':['*sokuon*'], // 特殊
            'ー':['-'],   // 長音記号はハイフンで入力
            'ゔ':['vu'] // 追加
        };

        // 拡張拗音（学習用に整理：Hepburn中心）
const YOON = {
  'きゃ':['kya'], 'きゅ':['kyu'], 'きょ':['kyo'],
  'ぎゃ':['gya'], 'ぎゅ':['gyu'], 'ぎょ':['gyo'],
  'しゃ':['sha','sya'], 'しゅ':['shu','syu'], 'しょ':['sho','syo'],
  'じゃ':['ja','jya','zya'], 'じゅ':['ju','jyu','zyu'], 'じょ':['jo','jyo','zyo'],
  'ちゃ':['cha','cya'], 'ちゅ':['chu','cyu'], 'ちょ':['cho','cyo'],
  'にゃ':['nya'], 'にゅ':['nyu'], 'にょ':['nyo'],
  'ひゃ':['hya'], 'ひゅ':['hyu'], 'ひょ':['hyo'],
  'びゃ':['bya'], 'びゅ':['byu'], 'びょ':['byo'],
  'ぴゃ':['pya'], 'ぴゅ':['pyu'], 'ぴょ':['pyo'],
  'みゃ':['mya'], 'みゅ':['myu'], 'みょ':['myo'],
  'りゃ':['rya'], 'りゅ':['ryu'], 'りょ':['ryo'],

  'ゔぁ':['va'], 'ゔぃ':['vi'], 'ゔぇ':['ve'], 'ゔぉ':['vo'], 'ゔゅ':['vyu'],

  // ★ここがポイント：ふぁ系は f + a/i/e/o/y を固定
  'ふぁ':['fa'], 'ふぃ':['fi'], 'ふぇ':['fe'], 'ふぉ':['fo'], 'ふゅ':['fyu'],

  'しぇ':['she'], 'じぇ':['je'], 'ちぇ':['che'],

  'てぃ':['ti'], 'でぃ':['di'], 'とぅ':['tu'], 'どぅ':['du'],

  // うぃ/うぇ/うぉ は wi/we/wo に統一（ui/ue/uo は削除）
  'うぃ':['wi'], 'うぇ':['we'], 'うぉ':['wo'],

  'つぁ':['tsa'], 'つぃ':['tsi'], 'つぇ':['tse'], 'つぉ':['tso']
};


        // 文字列→トークン（拗音を1トークン化）
        function tokenize(h){
            const arr=[...h]; const out=[];
            for(let i=0;i<arr.length;i++){
                const ch=arr[i], nx=arr[i+1];
                if(nx && ['ゃ','ゅ','ょ'].includes(nx) && YOON[ch+nx]){
                    out.push(ch+nx); i++;
                }else{
                    out.push(ch);
                }
            }
            return out;
        }

        // 次トークンの先頭子音/母音を得る（んの扱い判定用）
        function initialsOfToken(tok){
            let opts = romajiOfToken(tok);
            return new Set(opts.map(o=>o[0]||''));
        }

        // 単一トークンのローマ字候補を取得
        function romajiOfToken(tok){
            if(YOON[tok]) return YOON[tok].slice();
            if(tok==='ー') return ['-']; // 長音は必須
            if(BASE[tok]) return BASE[tok].slice();
            return [tok]; // 未知はそのまま
        }

        // 最適化された候補列挙（上限と枝刈り付き）
        function buildRomajiOptions(h){
            const MAX_OPTIONS = 128;
            const tokens = tokenize(h);
            const results = [];
            let bestFound = Infinity; // 最短長を追跡
            
            function dfs(i, acc){
                // 早期終了条件
                if (results.length >= MAX_OPTIONS) return;
                if (acc.length > bestFound + 3) return; // 枝刈り
                
                if(i >= tokens.length){ 
                    results.push(acc);
                    bestFound = Math.min(bestFound, acc.length);
                    return;
                }
                
                const t = tokens[i];

                if(t === 'っ'){ // 促音
                    if(i+1 < tokens.length){
                        const nextOpts = romajiOfToken(tokens[i+1]);
                        // 次の頭子音を重ねる（ch のときは tch / cch 両方許容）
                        nextOpts.forEach(no=>{
                            if(!no) return;
                            const head = no.startsWith('ch') ? ['t','c'] : [no[0]];
                            head.forEach(hc=>{
                                if(/[a-z]/.test(hc)) dfs(i+1, acc + hc); // 促音を前置
                            });
                        });
                        return; // 促音自体は文字を消費し、次へ
                    }else{
                        // 語末のっ は無視
                        dfs(i+1, acc);
                        return;
                    }
                }

                if(t === 'ん'){
                    // 次の頭が母音/ y なら nn or n'、それ以外でも nn を許可
                    const nextHead = (i+1 < tokens.length)? Array.from(initialsOfToken(tokens[i+1])) : [];
                    const vowelOrY = nextHead.some(c=>['a','i','u','e','o','y'].includes(c));
                    const labial = nextHead.some(c=>['b','m','p'].includes(c));
                    const cand = [];
                    if (vowelOrY) {
                        cand.push("nn", "n'");
                    } else {
                        cand.push("n", "nn");
                        if (labial) cand.push("m"); // 例: しんぱい → shimpai
                    }
                    cand.forEach(r=>dfs(i+1, acc+r));
                    return;
                }

                // 通常
                const opts = romajiOfToken(t);
                opts.forEach(o=>dfs(i+1, acc+o));
            }
            
            dfs(0,'');
            
            // 重複除去と長さフィルタ
            const uniqueResults = Array.from(new Set(results));
            
            // bestFound+2 文字以内の候補だけを残す
            if (bestFound !== Infinity) {
                return uniqueResults.filter(result => result.length <= bestFound + 2);
            }
            
            return uniqueResults;
        }

        // ひらがな文字列をローマ字に変換（最短候補を使用）
        function hiraganaToRomaji(hiragana) {
            const options = buildRomajiOptions(hiragana);
            // 最短のものを選択（通常は最も一般的）
            return options.reduce((shortest, current) => 
                current.length < shortest.length ? current : shortest, options[0] || '');
        }

        // ガイド初期化：カード選択直後に呼ぶ（複数候補対応）
        function setupTypingGuide(targetText) {
            const jpEl = document.getElementById('typingGuideJP');
            const subEl = document.getElementById('typingGuideSub');
            const romajiEl = document.getElementById('romajiGuide');
            const norm = toHiragana(targetText);

            // 上段は"原文そのまま"を表示（色は面で進捗）
            jpEl.style.setProperty('--fill', '0%');
            jpEl.textContent = targetText;

            // 下段は判定用の"ひらがな"を1文字ずつスパン化して点灯
            subEl.innerHTML = '';
            [...norm].forEach((ch, i) => {
                const span = document.createElement('span');
                span.className = 'char pending';
                span.dataset.index = i;
                span.textContent = ch;
                subEl.appendChild(span);
            });

            // 複数のローマ字候補を取得
            const romajiOptions = buildRomajiOptions(norm);
            typingState.targetOptions = romajiOptions;
            typingState.currentInputs = romajiOptions.map(() => ({
                position: 0,
                typed: '',
                completed: false
            }));
            typingState.typedKeys = '';

            // 最短候補をガイドとして表示
            const displayRomaji = romajiOptions.reduce((shortest, current) => 
                current.length < shortest.length ? current : shortest, romajiOptions[0] || '');

            romajiEl.innerHTML = '';
            [...displayRomaji].forEach((char, i) => {
                const span = document.createElement('span');
                span.className = 'romaji-char';
                span.dataset.index = i;
                span.textContent = char;
                romajiEl.appendChild(span);
            });

            // 最初の文字をハイライト
            if (displayRomaji.length > 0) {
                romajiEl.children[0].classList.add('current');
            }
            
            // 最適な候補でガイドを更新
            refreshRomajiGuideToLeader();
        }

        // 進捗更新：複数候補対応
        function updateTypingGuideProgress() {
            if (!gameState.selectedCard) return;
            const jpEl  = document.getElementById('typingGuideJP');
            const subEl = document.getElementById('typingGuideSub');

            const target = gameState.selectedCard.text;
            const normTarget = toHiragana(target);
            
            // 最も進んでいる候補の進捗を使用
            let maxProgress = 0;
            let maxPosition = 0;
            
            typingState.currentInputs.forEach((input, index) => {
                const targetLength = typingState.targetOptions[index].length;
                if (targetLength > 0) {
                    const progress = input.position / targetLength;
                    if (progress > maxProgress) {
                        maxProgress = progress;
                        maxPosition = input.position;
                    }
                }
            });
            
            const hiraganaMatched = Math.floor(maxProgress * normTarget.length);
            const fill = Math.max(0, Math.min(100, maxProgress * 100));
            jpEl.style.setProperty('--fill', `${fill}%`);

            // プログレスバーは非表示

            // 下段を1文字ずつ点灯
            const chars = subEl.querySelectorAll('.char');
            chars.forEach((el, i) => {
                el.classList.remove('matched','current','pending');
                if (i < hiraganaMatched) el.classList.add('matched');
                else if (i === hiraganaMatched && maxProgress < 1) el.classList.add('current');
                else el.classList.add('pending');
            });
        }

        // タイピング表示をクリア
        function clearTypingDisplay() {
            const jpEl = document.getElementById('typingGuideJP');
            const subEl = document.getElementById('typingGuideSub');
            const romajiEl = document.getElementById('romajiGuide');
            
            // 全ての表示をクリア
            jpEl.textContent = '';
            jpEl.style.setProperty('--fill', '0%');
            subEl.innerHTML = '';
            romajiEl.innerHTML = '';
            
            // タイピング状態もリセット
            typingState.targetOptions = [];
            typingState.currentInputs = [];
            typingState.typedKeys = '';
        }

        // ---- 高精度タイマー（ドリフト補正付き） ----
        let timerRaf = null;
        let timerDeadline = 0;       // performance.now() の絶対時刻
        let timerTotalMs = 12000;    // 表示用の合計時間

        function updateTimerRingUI(msLeft){
            const ring = document.getElementById('timerRing');
            const clamped = Math.max(0, msLeft);
            const sec = Math.ceil(clamped / 1000);
            const prog = Math.max(0, Math.min(1, clamped / timerTotalMs));
            const deg = prog * 360;
            ring.textContent = sec;
            ring.style.background =
                `conic-gradient(#feca57 ${deg}deg, rgba(255,255,255,0.2) ${deg}deg)`;
            // アクセシビリティ対応
            ring.setAttribute('aria-valuenow', sec);
        }

        function tickTimer(){
            const now = performance.now();
            const msLeft = timerDeadline - now;
            updateTimerRingUI(msLeft);
            if (msLeft <= 0){
                stopTimer();
                timeUp();  // 既存の関数をそのまま呼ぶ
                return;
            }
            timerRaf = requestAnimationFrame(tickTimer);
        }

        function startAccurateTimer(ms = 12000){
            stopTimer();
            timerTotalMs = ms;
            timerDeadline = performance.now() + ms;
            updateTimerRingUI(ms);
            timerRaf = requestAnimationFrame(tickTimer);
        }

        function adjustTimer(deltaMs){
            // ペナルティなど：締切を前後させる
            timerDeadline = Math.max(performance.now(), timerDeadline + deltaMs);
        }

        function stopTimer(){
            if (timerRaf){ cancelAnimationFrame(timerRaf); timerRaf = null; }
        }

        // ゲーム状態
        let gameState = {
            mode: null, // 'cpu' or 'pvp'
            maxHP: 200, // デフォルトHP
            players: [
                { name: 'プレイヤー1', hp: 200, maxHp: 200, avatar: '🔥', attribute: 'fire' },
                { name: 'CPU', hp: 200, maxHp: 200, avatar: '🤖', attribute: 'water' }
            ],
            currentPlayer: 0,
            selectedCard: null,
            hands: [[], []],
            deck: [],
            discard: [],
            timer: 15,
            timerInterval: null,
            gamePhase: 'cardSelect', // 'cardSelect', 'typing', 'result'
            soundEnabled: true,
            isPaused: false,
            playerStats: [
                { totalChars: 0, correctChars: 0, totalTime: 0, combo: 0, maxCombo: 0 },
                { totalChars: 0, correctChars: 0, totalTime: 0, combo: 0, maxCombo: 0 }
            ],
            stats: {
                totalChars: 0,
                correctChars: 0,
                totalTime: 0,
                combo: 0,
                maxCombo: 0
            }
        };

        // カードプール（実用的なタイピング練習用）
        const CARD_POOL = [
            // 2文字の単語（初級・20問）
            { text: 'ねこ', difficulty: 1, category: 'どうぶつ' },
            { text: 'いぬ', difficulty: 1, category: 'どうぶつ' },
            { text: 'すし', difficulty: 1, category: 'たべもの' },
            { text: 'そら', difficulty: 1, category: 'しぜん' },
            { text: 'やま', difficulty: 1, category: 'しぜん' },
            { text: 'かわ', difficulty: 1, category: 'しぜん' },
            { text: 'はな', difficulty: 1, category: 'しぜん' },
            { text: 'みず', difficulty: 1, category: 'しぜん' },
            { text: 'ゆき', difficulty: 1, category: 'しぜん' },
            { text: 'つき', difficulty: 1, category: 'しぜん' },
            { text: 'かさ', difficulty: 1, category: 'もの' },
            { text: 'うみ', difficulty: 1, category: 'しぜん' },
            { text: 'あめ', difficulty: 1, category: 'しぜん' },
            { text: 'ほし', difficulty: 1, category: 'しぜん' },
            { text: 'かに', difficulty: 1, category: 'どうぶつ' },
            { text: 'さる', difficulty: 1, category: 'どうぶつ' },
            { text: 'もり', difficulty: 1, category: 'しぜん' },
            { text: 'くも', difficulty: 1, category: 'しぜん' },
            { text: 'みち', difficulty: 1, category: 'もの' },
            { text: 'かぜ', difficulty: 1, category: 'しぜん' },
            
            // 3文字の単語（中級・20問）
            { text: 'たまご', difficulty: 2, category: 'たべもの' },
            { text: 'くるま', difficulty: 2, category: 'のりもの' },
            { text: 'きつね', difficulty: 2, category: 'どうぶつ' },
            { text: 'うさぎ', difficulty: 2, category: 'どうぶつ' },
            { text: 'さかな', difficulty: 2, category: 'どうぶつ' },
            { text: 'きのこ', difficulty: 2, category: 'しぜん' },
            { text: 'みかん', difficulty: 2, category: 'たべもの' },
            { text: 'りんご', difficulty: 2, category: 'たべもの' },
            { text: 'えほん', difficulty: 2, category: 'もの' },
            { text: 'とけい', difficulty: 2, category: 'もの' },
            { text: 'かばん', difficulty: 2, category: 'もの' },
            { text: 'おふろ', difficulty: 2, category: 'もの' },
            { text: 'こども', difficulty: 2, category: 'ひと' },
            { text: 'でんき', difficulty: 2, category: 'もの' },
            { text: 'すずめ', difficulty: 2, category: 'どうぶつ' },
            { text: 'おちゃ', difficulty: 2, category: 'たべもの' },
            { text: 'やさい', difficulty: 2, category: 'たべもの' },
            { text: 'あさひ', difficulty: 2, category: 'しぜん' },
            { text: 'すいか', difficulty: 2, category: 'たべもの' },
            { text: 'おかし', difficulty: 2, category: 'たべもの' },

            // 4文字の単語（上級・20問）
            { text: 'ひこうき', difficulty: 3, category: 'のりもの' },
            { text: 'でんしゃ', difficulty: 3, category: 'のりもの' },
            { text: 'おにぎり', difficulty: 3, category: 'たべもの' },
            { text: 'にわとり', difficulty: 3, category: 'どうぶつ' },
            { text: 'せんせい', difficulty: 3, category: 'ひと' },
            { text: 'あさがお', difficulty: 3, category: 'しぜん' },
            { text: 'たいよう', difficulty: 3, category: 'しぜん' },
            { text: 'やきそば', difficulty: 3, category: 'たべもの' },
            { text: 'えんぴつ', difficulty: 3, category: 'もの' },
            { text: 'うわばき', difficulty: 3, category: 'もの' },
            { text: 'くつした', difficulty: 3, category: 'もの' },
            { text: 'こくばん', difficulty: 3, category: 'もの' },
            { text: 'せんたく', difficulty: 3, category: 'せいかつ' },
            { text: 'たいいく', difficulty: 3, category: 'がくしゅう' },
            { text: 'こうえん', difficulty: 3, category: 'ばしょ' },
            { text: 'どようび', difficulty: 3, category: 'にちじ' },
            { text: 'かようび', difficulty: 3, category: 'にちじ' },
            { text: 'にちよう', difficulty: 3, category: 'にちじ' },
            { text: 'ざぶとん', difficulty: 3, category: 'もの' },
            { text: 'そうじき', difficulty: 3, category: 'もの' },
            
            // 5〜6文字の単語（上級・30問）
            { text: 'しんかんせん', difficulty: 4, category: 'のりもの' },
            { text: 'おべんとう', difficulty: 4, category: 'たべもの' },
            { text: 'たいようけい', difficulty: 4, category: 'しぜん' },
            { text: 'きょうしつ', difficulty: 4, category: 'ばしょ' },
            { text: 'どうぶつえん', difficulty: 4, category: 'ばしょ' },
            { text: 'すいぞくかん', difficulty: 4, category: 'ばしょ' },
            { text: 'おんがくしつ', difficulty: 4, category: 'ばしょ' },
            { text: 'あさごはん', difficulty: 4, category: 'たべもの' },
            { text: 'えいがかん', difficulty: 4, category: 'ばしょ' },
            { text: 'まほうつかい', difficulty: 4, category: 'ファンタジー' },
            { text: 'ほいくしつ', difficulty: 4, category: 'ばしょ' },
            { text: 'てがみばこ', difficulty: 4, category: 'もの' },
            { text: 'さくらまつり', difficulty: 4, category: 'イベント' },
            { text: 'かんこうバス', difficulty: 4, category: 'のりもの' },
            { text: 'うちゅうせん', difficulty: 4, category: 'のりもの' },
            { text: 'ホームラン', difficulty: 4, category: 'スポーツ' },
            { text: 'おかしづくり', difficulty: 4, category: 'せいかつ' },
            { text: 'たいいくかん', difficulty: 4, category: 'ばしょ' },
            { text: 'ゆうえんち', difficulty: 4, category: 'ばしょ' },
            { text: 'としょしつ', difficulty: 4, category: 'ばしょ' },
            { text: 'きょうかしょ', difficulty: 4, category: 'がくしゅう' },
            { text: 'けいさつしょ', difficulty: 4, category: 'ばしょ' },
            { text: 'あさのしたく', difficulty: 4, category: 'せいかつ' },
            { text: 'おひるやすみ', difficulty: 4, category: 'せいかつ' },
            { text: 'じゅぎょう', difficulty: 4, category: 'がくしゅう' },
            { text: 'けんがくかい', difficulty: 4, category: 'がくしゅう' },
            { text: 'おんがくかい', difficulty: 4, category: 'イベント' },
            { text: 'うんどうかい', difficulty: 4, category: 'イベント' },
            { text: 'じてんしゃ', difficulty: 4, category: 'のりもの' },
            { text: 'かいだんした', difficulty: 4, category: 'ばしょ' },

            // 7〜8文字の単語（最上級・20問）
            { text: 'アイスクリーム', difficulty: 5, category: 'たべもの' },
            { text: 'サッカーボール', difficulty: 5, category: 'スポーツ' },
            { text: 'コンピューター', difficulty: 5, category: 'もの' },
            { text: 'ランドセルカバー', difficulty: 5, category: 'もの' },
            { text: 'ひまわりばたけ', difficulty: 5, category: 'しぜん' },
            { text: 'じゆうけんきゅう', difficulty: 5, category: 'がくしゅう' },
            { text: 'しゅくだいちょう', difficulty: 5, category: 'がくしゅう' },
            { text: 'おにごっこあそび', difficulty: 5, category: 'あそび' },
            { text: 'はなやさんのにわ', difficulty: 5, category: 'ばしょ' },
            { text: 'パソコンルーム', difficulty: 5, category: 'ばしょ' },
            { text: 'すいえいたいかい', difficulty: 5, category: 'イベント' },
            { text: 'じどうしゃどう', difficulty: 5, category: 'のりもの' },
            { text: 'クリスマスツリー', difficulty: 5, category: 'イベント' },
            { text: 'バスケットボール', difficulty: 5, category: 'スポーツ' },
            { text: 'てがみのかきかた', difficulty: 5, category: 'がくしゅう' },
            { text: 'えいごべんきょう', difficulty: 5, category: 'がくしゅう' },
            { text: 'たいいくずわり', difficulty: 5, category: 'がくしゅう' },
            { text: 'こうさくクラブ', difficulty: 5, category: 'クラブ' },
            { text: 'がっきゅういいん', difficulty: 5, category: 'がくしゅう' },
            { text: 'かがくはっぴょう', difficulty: 5, category: 'がくしゅう' },

            // 9〜12文字の単語（超上級・20問）
            { text: 'おしょうがつやすみ', difficulty: 6, category: 'イベント' },
            { text: 'かんきょうもんだい', difficulty: 6, category: 'がくしゅう' },
            { text: 'きょうりゅうはかば', difficulty: 6, category: 'ばしょ' },
            { text: 'じしんけいほうシステム', difficulty: 6, category: 'しぜん' },
            { text: 'ファミリーレストラン', difficulty: 6, category: 'ばしょ' },
            { text: 'しょうてんがいストリート', difficulty: 6, category: 'ばしょ' },
            { text: 'きゅうきゅうしゃしどう', difficulty: 6, category: 'のりもの' },
            { text: 'がくえんさいじっし', difficulty: 6, category: 'イベント' },
            { text: 'まんがライブラリー', difficulty: 6, category: 'ばしょ' },
            { text: 'サイエンスミュージアム', difficulty: 6, category: 'ばしょ' },
            { text: 'どうぶつあいごセンター', difficulty: 6, category: 'ばしょ' },
            { text: 'にゅうがくしきセレモニー', difficulty: 6, category: 'イベント' },
            { text: 'しぜんかんさつきょうしつ', difficulty: 6, category: 'がくしゅう' },
            { text: 'ショッピングモール', difficulty: 6, category: 'ばしょ' },
            { text: 'ハンバーガーセット', difficulty: 6, category: 'たべもの' },
            { text: 'ほうかごこどもクラブ', difficulty: 6, category: 'クラブ' },
            { text: 'じゅくごれんしゅうちょう', difficulty: 6, category: 'がくしゅう' },
            { text: 'とうきょうスカイツリー', difficulty: 6, category: 'ばしょ' },
            { text: 'えいがさいパンフレット', difficulty: 6, category: 'イベント' },
            { text: 'うんどうかいプログラム', difficulty: 6, category: 'イベント' },
            
            // 医療カテゴリー（回復効果・15問）
            { text: 'くすり', difficulty: 2, category: 'いりょう' },
            { text: 'びょういん', difficulty: 3, category: 'いりょう' },
            { text: 'いしゃ', difficulty: 2, category: 'いりょう' },
            { text: 'かんごし', difficulty: 3, category: 'いりょう' },
            { text: 'ちりょう', difficulty: 3, category: 'いりょう' },
            { text: 'けんこう', difficulty: 3, category: 'いりょう' },
            { text: 'しんだん', difficulty: 3, category: 'いりょう' },
            { text: 'ほうたい', difficulty: 3, category: 'いりょう' },
            { text: 'ちゅうしゃ', difficulty: 3, category: 'いりょう' },
            { text: 'たいおん', difficulty: 3, category: 'いりょう' },
            { text: 'きゅうきゅう', difficulty: 4, category: 'いりょう' },
            { text: 'やくざいし', difficulty: 4, category: 'いりょう' },
            { text: 'りはびり', difficulty: 3, category: 'いりょう' },
            { text: 'けんしん', difficulty: 3, category: 'いりょう' },
            { text: 'ばんそうこう', difficulty: 4, category: 'いりょう' }
        ];



        // 全角文字を半角に変換（改良版）
        function normalizeInput(text) {
            if (!text) return '';
            return text
                // 全角英数
                .replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
                // 右/左のカール・プライム類も吸収
                .replace(/[\u2018\u2019\u2032\uFF07']/g, "'")
                // いろんなダッシュを半角ハイフンに（長音「ー」除外）
                .replace(/[\u2010-\u2015\u2212\uFF0D\uFE63]/g, "-")
                .toLowerCase();
        }

        // Fisher-Yates シャッフル（公平性向上）
        function shuffle(array) {
            const a = [...array];
            const r = new Uint32Array(1);
            for (let i = a.length - 1; i > 0; i--) {
                crypto.getRandomValues(r);
                const j = r[0] % (i + 1);
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }

        // ゲーム初期化
        function initGame() {
            // 選択されたHPを適用
            gameState.players.forEach(player => {
                player.hp = gameState.maxHP;
                player.maxHp = gameState.maxHP;
            });
            
            // デッキをシャッフル
            gameState.deck = shuffle(CARD_POOL);
            
            // 初期手札を配る
            for (let i = 0; i < 2; i++) {
                gameState.hands[i] = [];
                for (let j = 0; j < 5; j++) {
                    if (gameState.deck.length > 0) {
                        gameState.hands[i].push(gameState.deck.pop());
                    }
                }
            }
            
            // UI更新
            updateUI();
            drawCards();
            
            // 最初のターン開始
            startTurn();
        }

        // モード選択
        function selectMode(mode) {
            // 前の選択を解除
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // 新しい選択
            document.getElementById(mode === 'cpu' ? 'cpuModeBtn' : 'pvpModeBtn').classList.add('selected');
            
            gameState.mode = mode;
            document.getElementById('characterSelection').classList.remove('hidden');
            
            if (mode === 'pvp') {
                document.getElementById('player2Setup').classList.remove('hidden');
                gameState.players[1].name = 'プレイヤー2';
                gameState.players[1].avatar = '💧';
            } else {
                document.getElementById('player2Setup').classList.add('hidden');
            }
            
            // プレイヤー1の名前入力フィールドを選択状態にする
            setTimeout(() => {
                const nameInput = document.getElementById('player1NameInput');
                nameInput.focus();
                nameInput.select();
            }, 100);
            
            // 名前入力フィールドのイベントリスナーを設定
            document.getElementById('player1NameInput').addEventListener('focus', function() {
                this.select();
            });
            
            if (mode === 'pvp') {
                document.getElementById('player2NameInput').addEventListener('focus', function() {
                    this.select();
                });
            }

            // デフォルト選択（迷ったらすぐ進める）
            selectCharacter('fire', 1);
            if (mode === 'pvp') selectCharacter('water', 2);
            checkSetupComplete();
        }

        // HP選択
        function selectHP(hp) {
            // 前の選択を解除
            document.querySelectorAll('.hp-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // 新しい選択
            document.querySelector(`[data-hp="${hp}"]`).classList.add('selected');
            
            gameState.maxHP = hp;
            gameState.players.forEach(player => {
                player.hp = hp;
                player.maxHp = hp;
            });
            
            checkSetupComplete();
        }

        // キャラクター選択
        function selectCharacter(attribute, player) {
            // 該当プレイヤーの前の選択を解除
            document.querySelectorAll(`[data-player="${player}"]`).forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // 新しい選択
            document.querySelector(`[data-attr="${attribute}"][data-player="${player}"]`).classList.add('selected');
            
            const avatars = {
                fire: '🔥',
                water: '💧',
                thunder: '⚡',
                wind: '🌪️',
                earth: '🌱',
                light: '✨'
            };
            
            gameState.players[player - 1].attribute = attribute;
            gameState.players[player - 1].avatar = avatars[attribute];
            
            // 名前を更新
            const nameInput = document.getElementById(`player${player}NameInput`);
            if (nameInput) {
                gameState.players[player - 1].name = nameInput.value || `プレイヤー${player}`;
            }
            
            // 次のプレイヤーの名前入力にフォーカス（2人対戦の場合）
            if (player === 1 && gameState.mode === 'pvp') {
                setTimeout(() => {
                    const player2Input = document.getElementById('player2NameInput');
                    player2Input.focus();
                    player2Input.select();
                }, 100);
            }
            
            checkSetupComplete();
        }
        
        // セットアップ完了チェック
        function checkSetupComplete() {
            const player1Selected = document.querySelector('[data-player="1"].selected');
            const player2Selected = gameState.mode === 'cpu' || document.querySelector('[data-player="2"].selected');
            
            document.getElementById('nextBtn').disabled = !(player1Selected && player2Selected);
        }
        
        // ゲームルール表示
        function showGameRules() {
            // 名前を最終更新
            gameState.players[0].name = document.getElementById('player1NameInput').value || 'プレイヤー1';
            if (gameState.mode === 'pvp') {
                gameState.players[1].name = document.getElementById('player2NameInput').value || 'プレイヤー2';
            }
            
            document.getElementById('characterSelection').classList.add('hidden');
            document.getElementById('gameRules').classList.remove('hidden');
        }

        // ゲーム開始
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            
            // 2人対戦の場合はルーレットでターン決定
            if (gameState.mode === 'pvp') {
                showRouletteAnimation();
            } else {
                document.getElementById('gameContainer').classList.remove('hidden');
                initGame();
            }
        }

        // ルーレット演出表示
        function showRouletteAnimation() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'roulette-overlay';
                
                const container = document.createElement('div');
                container.className = 'roulette-container';
                
                // XSS対策：テンプレートを使わずDOM構築
                const title = document.createElement('div');
                title.className = 'roulette-title';
                title.textContent = '🎯 先攻を決めよう！';
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info-simple';
                
                // プレイヤー1カード
                const leftCard = document.createElement('div');
                leftCard.className = 'player-card left';
                leftCard.innerHTML = `
                    <div class="player-avatar-simple">${gameState.players[0].avatar}</div>
                    <div class="player-side">左半分</div>
                `;
                const leftName = document.createElement('div');
                leftName.className = 'player-name-simple';
                leftName.textContent = gameState.players[0].name;
                leftCard.insertBefore(leftName, leftCard.lastElementChild);
                
                // プレイヤー2カード
                const rightCard = document.createElement('div');
                rightCard.className = 'player-card right';
                rightCard.innerHTML = `
                    <div class="player-avatar-simple">${gameState.players[1].avatar}</div>
                    <div class="player-side">右半分</div>
                `;
                const rightName = document.createElement('div');
                rightName.className = 'player-name-simple';
                rightName.textContent = gameState.players[1].name;
                rightCard.insertBefore(rightName, rightCard.lastElementChild);
                
                playerInfo.appendChild(leftCard);
                playerInfo.appendChild(rightCard);
                
                const wheel = document.createElement('div');
                wheel.className = 'roulette-wheel';
                wheel.id = 'rouletteWheel';
                wheel.innerHTML = `
                    <div class="roulette-pointer"></div>
                    <div class="roulette-center">🎲</div>
                `;
                
                const result = document.createElement('div');
                result.className = 'roulette-result';
                result.id = 'rouletteResult';
                
                container.appendChild(title);
                container.appendChild(playerInfo);
                container.appendChild(wheel);
                container.appendChild(result);
                
                overlay.appendChild(container);
                document.body.appendChild(overlay);
                
                // ルーレット開始
                setTimeout(() => {
                    spinRoulette(overlay, resolve);
                }, 500);
            });
        }

        // ルーレット回転処理
        function spinRoulette(overlay, callback) {
            const wheel = document.getElementById('rouletteWheel');
            const resultEl = document.getElementById('rouletteResult');
            
            // ランダムな最終角度を決定（5回転 + ランダム）
            const baseRotation = 1800; // 5回転
            const randomRotation = Math.random() * 360;
            const finalRotation = baseRotation + randomRotation;
            
            // 結果を決定（左半分：プレイヤー1、右半分：プレイヤー2）
            const normalizedAngle = randomRotation % 360;
            const winner = normalizedAngle < 180 ? 0 : 1;
            gameState.currentPlayer = winner;
            
            // CSS変数に最終角度を設定
            wheel.style.setProperty('--final-rotation', `${finalRotation}deg`);
            
            // 回転アニメーション開始
            wheel.classList.add('roulette-spinning');
            
            // 回転音（簡易）
            playRouletteSound();
            
            // 結果表示
            setTimeout(() => {
                const winnerName = gameState.players[winner].name;
                const winnerAvatar = gameState.players[winner].avatar;
                
                // XSS対策：DOM構築で名前を安全に挿入
                const resultContainer = document.createElement('div');
                resultContainer.style.cssText = 'display: flex; align-items: center; justify-content: center; gap: 15px;';
                
                const avatarDiv = document.createElement('div');
                avatarDiv.style.fontSize = '32px';
                avatarDiv.textContent = winnerAvatar;
                
                const textDiv = document.createElement('div');
                
                const winText = document.createElement('div');
                winText.style.cssText = 'font-size: 20px; color: #feca57;';
                winText.textContent = `🎉 ${winnerName}の先攻！`;
                
                const subText = document.createElement('div');
                subText.style.cssText = 'font-size: 14px; opacity: 0.8; margin-top: 5px;';
                subText.textContent = 'ゲームを開始します...';
                
                textDiv.appendChild(winText);
                textDiv.appendChild(subText);
                resultContainer.appendChild(avatarDiv);
                resultContainer.appendChild(textDiv);
                
                resultEl.innerHTML = '';
                resultEl.appendChild(resultContainer);
                
                // 勝利音
                playSound('success');
                
                // ゲーム開始
                setTimeout(() => {
                    overlay.remove();
                    document.getElementById('gameContainer').classList.remove('hidden');
                    initGame();
                    callback();
                }, 1500);
            }, 2200);
        }

        // ルーレット音（回転音）
        function playRouletteSound() {
            if (!gameState.soundEnabled) return;
            
            ensureAudio();
            if (!audioCtx) return;
            
            // 回転音を3秒間再生
            let frequency = 200;
            const duration = 3000;
            const startTime = audioCtx.currentTime;
            
            function createTick(time, freq) {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                oscillator.frequency.setValueAtTime(freq, time);
                gainNode.gain.setValueAtTime(0.05, time);
                gainNode.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
                
                oscillator.start(time);
                oscillator.stop(time + 0.1);
            }
            
            // 徐々に間隔を広げながらティック音を生成
            let tickInterval = 50; // 初期間隔（ms）
            let currentTime = startTime;
            
            while (currentTime - startTime < duration / 1000) {
                createTick(currentTime, frequency + Math.random() * 100);
                
                // 時間が経つにつれて間隔を広げる（減速効果）
                const progress = (currentTime - startTime) / (duration / 1000);
                tickInterval = 50 + (progress * 200); // 50ms から 250ms へ
                
                currentTime += tickInterval / 1000;
            }
        }

        // UI更新
        function updateUI() {
            // プレイヤー情報更新
            for (let i = 0; i < 2; i++) {
                const player = gameState.players[i];
                document.getElementById(`player${i + 1}Name`).textContent = player.name;
                document.getElementById(`player${i + 1}Avatar`).textContent = player.avatar;
                
                const hpPercent = Math.max(0, Math.min(100, (player.hp / player.maxHp) * 100));
                document.getElementById(`player${i + 1}HpBar`).style.width = `${hpPercent}%`;
                document.getElementById(`player${i + 1}HpText`).textContent = `${player.hp}/${player.maxHp}`;
            }
            
            // ターン表示
            document.getElementById('turnDisplay').textContent = 
                `${gameState.players[gameState.currentPlayer].name}のターン`;
                
            // フェーズ表示
            updatePhaseDisplay();
        }
        
        // フェーズ表示更新
        function updatePhaseDisplay() {
            const phaseDisplay = document.getElementById('phaseDisplay');
            
            switch (gameState.gamePhase) {
                case 'cardSelect':
                    phaseDisplay.textContent = 'カードを選択してください';
                    break;
                case 'typing':
                    phaseDisplay.textContent = 'タイピング中...';
                    break;
                case 'result':
                    phaseDisplay.textContent = '結果表示';
                    break;
                default:
                    phaseDisplay.textContent = '';
            }
        }

        // プレイヤーの手札表示（左右に配置）
        function drawPlayerHand() {
            // 既存の手札コンテナを削除
            document.querySelectorAll('.player-hand').forEach(el => el.remove());
            
            // 左側（プレイヤー1の手札）
            const leftHand = document.createElement('div');
            leftHand.className = 'player-hand left';
            leftHand.id = 'leftPlayerHand';
            
            // 右側（プレイヤー2の手札）
            const rightHand = document.createElement('div');
            rightHand.className = 'player-hand right';
            rightHand.id = 'rightPlayerHand';
            
            document.querySelector('.card-area').appendChild(leftHand);
            document.querySelector('.card-area').appendChild(rightHand);
            
            // 両方のプレイヤーの手札を表示
            [0, 1].forEach(playerIndex => {
                const hand = gameState.hands[playerIndex];
                const container = playerIndex === 0 ? leftHand : rightHand;
                
                // 手札が6枚未満なら1枚引く
                if (gameState.deck.length > 0 && hand.length < 6) {
                    hand.push(gameState.deck.pop());
                }
                
                hand.forEach((card, index) => {
                    const handCard = document.createElement('div');
                    handCard.className = 'hand-card';
                    
                    // 現在のプレイヤーの手札は少し明るく表示
                    if (playerIndex === gameState.currentPlayer) {
                        handCard.style.opacity = '1';
                        handCard.style.border = '2px solid rgba(254, 202, 87, 0.5)';
                    }
                    
                    handCard.innerHTML = `
                        <div style="font-weight: 700; font-size: 11px;">${card.text}</div>
                        <div style="font-size: 8px; opacity: 0.8;">${'★'.repeat(card.difficulty)}</div>
                        <div style="font-size: 7px; opacity: 0.7;">${card.category}</div>
                    `;
                    container.appendChild(handCard);
                });
            });
        }

        // カード描画（メイン選択エリア）
        function drawCards() {
            const container = document.getElementById('cardsContainer');
            container.innerHTML = '';
            
            const currentHand = gameState.hands[gameState.currentPlayer];
            
            // 手札が6枚未満なら1枚引く
            if (gameState.deck.length > 0 && currentHand.length < 6) {
                currentHand.push(gameState.deck.pop());
            }
            
            // カードを3枚ずつ表示（最大6枚）
            const displayCards = currentHand.slice(0, 6);
            
            displayCards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                const isHealCard = card.category === 'いりょう';
                cardElement.className = isHealCard ? 'card heal' : 'card attack';
                cardElement.onclick = () => selectCard(index);
                
                // キーボードアクセシビリティ対応
                cardElement.tabIndex = 0;
                cardElement.setAttribute('role', 'button');
                cardElement.setAttribute('aria-label', `${card.text}、難易度${card.difficulty}`);
                cardElement.addEventListener('keydown', e => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        selectCard(index);
                    }
                });
                
                const stars = '★'.repeat(card.difficulty);
                const categoryDisplay = isHealCard ? '💚 いりょう' : '⚔️ ' + card.category;
                
                // 文字数に応じてテキストサイズクラスを決定
                const textLength = card.text.length;
                let textSizeClass = 'medium';
                if (textLength <= 3) textSizeClass = 'short';
                else if (textLength <= 6) textSizeClass = 'medium';
                else if (textLength <= 9) textSizeClass = 'long';
                else if (textLength <= 12) textSizeClass = 'very-long';
                else textSizeClass = 'extra-long';
                
                cardElement.innerHTML = `
                    <div class="card-text ${textSizeClass}">${card.text}</div>
                    <div class="card-difficulty">${stars}</div>
                    <div class="card-category">${categoryDisplay}</div>
                `;
                
                container.appendChild(cardElement);
            });
            
            // アニメーション
            setTimeout(() => {
                container.classList.add('active');
            }, 100);
        }

        // カード選択
        function selectCard(index) {
            if (gameState.gamePhase !== 'cardSelect') return;
            
            // 前の選択を解除
            document.querySelectorAll('.card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // 新しい選択
            document.querySelectorAll('.card')[index].classList.add('selected');
            gameState.selectedCard = gameState.hands[gameState.currentPlayer][index];
            
            // タイピングガイドを設定
            setupTypingGuide(gameState.selectedCard.text);
            
            // 入力フェーズに移行
            startTypingPhase();
        }

        // カウントダウン表示
        function showCountdown() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'countdown-overlay';
                
                const numberEl = document.createElement('div');
                numberEl.className = 'countdown-number';
                overlay.appendChild(numberEl);
                
                document.body.appendChild(overlay);
                
                // Ready → Go!!! の順番で表示
                numberEl.textContent = 'Ready';
                
                setTimeout(() => {
                    numberEl.textContent = 'Go!!!';
                    setTimeout(() => {
                        overlay.remove();
                        resolve();
                    }, 800);
                }, 1200); // Readyを1.2秒表示
            });
        }

        // タイピングフェーズ開始
        async function startTypingPhase() {
            gameState.gamePhase = 'typing';
            gameState.timer = 12;
            
            // タイマーリングを即更新
            const timerRing = document.getElementById('timerRing');
            timerRing.textContent = 12;
            timerRing.style.background = 'conic-gradient(#feca57 360deg, rgba(255,255,255,0.2) 360deg)';
            
            // カウントダウン表示
            await showCountdown();
            
            // タイピングハンドラーを有効化
            enableTyping();
            
            // タイマー開始
            startTimer();
        }

        // タイマー開始
        function startTimer() { 
            startAccurateTimer(12000); 
        }

        // 複数候補対応のタイピング状態
        let typingState = {
            targetOptions: [], // 複数のローマ字候補
            currentInputs: [], // 各候補での現在の入力状況
            typedKeys: ''
        };

        // キーボード入力処理（複数候補対応）
        function handleKeyPress(event) {
            if (gameState.gamePhase !== 'typing' || gameState.isPaused) return;
            
            // IME入力中は処理しない
            if (isComposing) return;
            
            // キー長押しの暴発を無効化
            if (event.repeat) return;
            
            // 全角文字を半角に変換
            let key = normalizeInput(event.key);
            if (key === 'subtract') key = '-'; // NumpadSubtract 対応
            
            // 特殊キーの処理
            if (key === 'enter') {
                event.preventDefault();
                // いずれかの候補が完了していれば送信
                if (typingState.currentInputs.some(input => input.completed)) {
                    submitAnswer();
                }
                return;
            }
            
            if (key === 'escape') {
                event.preventDefault();
                giveUp();
                return;
            }
            
            // アルファベット・ハイフン・アポストロフィを許可（全角も対応）
            if (!/^[a-z\-']$/.test(key)) return;
            
            event.preventDefault();
            
            // 全候補に対してキー入力をチェック
            let anyMatch = false;
            let completedCount = 0;
            
            typingState.currentInputs.forEach((input, index) => {
                if (input.completed) {
                    completedCount++;
                    return; // 既に完了している候補はスキップ
                }
                
                const targetRomaji = typingState.targetOptions[index];
                const expectedKey = targetRomaji[input.position];
                
                if (key === expectedKey) {
                    input.position++;
                    input.typed += key;
                    anyMatch = true;
                    
                    // この候補が完了したかチェック
                    if (input.position >= targetRomaji.length) {
                        input.completed = true;
                        completedCount++;
                        console.log(`候補${index}完了: ${targetRomaji}`);
                    }
                }
            });
            
            if (anyMatch) {
                // 正しいキー
                typingState.typedKeys += key;
                
                // 候補を間引く：入力プレフィックスに一致するもののみ残す
                const pref = typingState.typedKeys;
                const validIndices = [];
                
                typingState.targetOptions.forEach((opt, i) => {
                    if (opt.startsWith(pref)) {
                        validIndices.push(i);
                    }
                });
                
                // フィルタリング実行
                typingState.targetOptions = validIndices.map(i => typingState.targetOptions[i]);
                typingState.currentInputs = validIndices.map(i => typingState.currentInputs[i]);
                
                updateRomajiDisplay();
                updateTypingGuideProgress();
                refreshRomajiGuideToLeader();
                
                // いずれかの候補が完了したら即座に送信
                if (completedCount > 0) {
                    console.log('入力完了検出 - 即座に送信');
                    // タイマーを停止
                    stopTimer();
                    // 少し遅延を入れて確実に処理
                    setTimeout(() => {
                        submitAnswer();
                    }, 50);
                }
            } else {
                // 間違ったキー - 2秒ペナルティ
                adjustTimer(-2000);           // ← これだけでOK
                showPenaltyEffect();
                playSound('fail');
            }
        }

        // ローマ字ガイドを最も進んだ候補に更新
        function refreshRomajiGuideToLeader() {
            const romajiEl = document.getElementById('romajiGuide');
            if (!typingState.currentInputs.length) return;

            let leaderIdx = 0, best = -1;
            typingState.currentInputs.forEach((inp, i) => {
                if (inp.position > best) { best = inp.position; leaderIdx = i; }
            });

            const leader = typingState.targetOptions[leaderIdx] || '';
            const pos = typingState.currentInputs[leaderIdx].position || 0;

            romajiEl.innerHTML = [...leader].map((ch, i) =>
                `<span class="romaji-char ${i < pos ? 'typed' : (i === pos ? 'current' : '')}" data-index="${i}">${ch}</span>`
            ).join('');
        }

        // ローマ字表示更新（複数候補対応）
        function updateRomajiDisplay() {
            refreshRomajiGuideToLeader();
        }

        // エフェクトレイヤー取得/作成
        function getOrCreateFxLayer() {
            let fxLayer = document.querySelector('.fx-layer');
            if (!fxLayer) {
                fxLayer = document.createElement('div');
                fxLayer.className = 'fx-layer';
                fxLayer.setAttribute('aria-hidden', 'true');
                document.body.appendChild(fxLayer);
            }
            return fxLayer;
        }

        function getFXScale(){
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return 0.4;
            const mem   = navigator.deviceMemory || 4;
            const cores = navigator.hardwareConcurrency || 4;
            const saveData = navigator.connection && navigator.connection.saveData;
            let scale = 1.0;
            if (mem <= 2)   scale *= 0.5;
            if (cores <= 4) scale *= 0.7;
            if (saveData)   scale *= 0.6;
            if (Math.min(window.innerWidth, window.innerHeight) < 700) scale *= 0.8; // 小画面
            return Math.max(0.3, Math.min(1, scale));
        }

        // 属性別設定テーブル
        const ATTACK_CONFIGS = {
            fire: {
                colors: ['#ff6b6b', '#feca57', '#ff9f43'],
                particles: 80,
                speed: 1.0,
                flashColor: 'rgba(255, 107, 107, 0.6)',
                glowColor: '#ff6b6b'
            },
            water: {
                colors: ['#4ecdc4', '#76e0ff', '#00d2d3'],
                particles: 100,
                speed: 1.2,
                flashColor: 'rgba(76, 224, 255, 0.5)',
                glowColor: '#4ecdc4'
            },
            thunder: {
                colors: ['#ffe66d', '#fff', '#f1c40f'],
                particles: 60,
                speed: 2.0,
                flashColor: 'rgba(255, 255, 255, 0.8)',
                glowColor: '#ffe66d'
            },
            wind: {
                colors: ['#95e1d3', '#a8e6cf', '#88d8c0'],
                particles: 70,
                speed: 1.5,
                flashColor: 'rgba(149, 225, 211, 0.4)',
                glowColor: '#95e1d3'
            },
            earth: {
                colors: ['#a8e6cf', '#8bc34a', '#689f38'],
                particles: 60,
                speed: 0.8,
                flashColor: 'rgba(168, 230, 207, 0.5)',
                glowColor: '#a8e6cf'
            },
            light: {
                colors: ['#ffd93d', '#ffffff', '#f39c12'],
                particles: 90,
                speed: 1.8,
                flashColor: 'rgba(255, 255, 255, 0.9)',
                glowColor: '#ffd93d'
            }
        };

        // 攻撃アニメーション実行
        async function playAttackAnimation({ attr, from, targetEl, impactMs = 600 }) {
            const config = ATTACK_CONFIGS[attr];
            const fxLayer = getOrCreateFxLayer();
            
            // 攻撃者と対象の位置を取得
            const attackerEl = document.getElementById(`player${gameState.currentPlayer + 1}Avatar`);
            const attackerRect = attackerEl.getBoundingClientRect();
            const targetRect = targetEl.getBoundingClientRect();
            
            const startX = from === 'left' ? attackerRect.right : attackerRect.left;
            const startY = attackerRect.top + attackerRect.height / 2;
            const endX = targetRect.left + targetRect.width / 2;
            const endY = targetRect.top + targetRect.height / 2;

            // フェーズ1: 溜めエフェクト
            await playChargeEffect(attackerEl, config);
            
            // フェーズ2: 飛び道具移動
            await playProjectileEffect(fxLayer, attr, config, startX, startY, endX, endY, impactMs);
            
            // フェーズ3: ヒットエフェクト
            await playImpactEffect(fxLayer, attr, config, endX, endY);
            
            return Promise.resolve();
        }

        // フェーズ1: 溜めエフェクト
        function playChargeEffect(attackerEl, config) {
            return new Promise((resolve) => {
                // 溜め音
                playSound('charge');
                
                // グロー効果
                attackerEl.style.setProperty('--glow-color', config.glowColor);
                attackerEl.style.animation = 'chargeGlow 300ms ease-out forwards';
                
                setTimeout(() => {
                    attackerEl.style.animation = '';
                    attackerEl.style.transform = '';
                    attackerEl.style.boxShadow = '';
                    resolve();
                }, 300);
            });
        }

        // フェーズ2: 飛び道具エフェクト（画面全体スケール）
        function playProjectileEffect(fxLayer, attr, config, startX, startY, endX, endY, duration) {
            return new Promise((resolve) => {
                const projectile = createProjectile(attr, config, startX, startY);
                fxLayer.appendChild(projectile);
                
                // 移動アニメーション（画面全体を使った大きな軌道）
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                
                // 弧を描く軌道を計算（より大きなスケール）
                const midX = (startX + endX) / 2;
                const midY = Math.min(startY, endY) - Math.abs(deltaX) * 0.3; // より高い弧
                
                const keyframes = [
                    { 
                        transform: `translate3d(0, 0, 0) scale(1)`,
                        opacity: 1
                    },
                    { 
                        transform: `translate3d(${(midX - startX)}px, ${(midY - startY)}px, 0) scale(1.5)`,
                        opacity: 1,
                        offset: 0.5
                    },
                    { 
                        transform: `translate3d(${deltaX}px, ${deltaY}px, 0) scale(2)`,
                        opacity: 0.8
                    }
                ];
                
                projectile.animate(keyframes, {
                    duration: duration * config.speed,
                    easing: 'cubic-bezier(0.22, 1, 0.36, 1)',
                    fill: 'forwards'
                }).addEventListener('finish', () => {
                    projectile.remove();
                    resolve();
                });
            });
        }

        // 属性別飛び道具作成（大型化）
        function createProjectile(attr, config, x, y) {
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.style.left = x + 'px';
            projectile.style.top = y + 'px';
            
            switch (attr) {
                case 'fire':
                    projectile.innerHTML = '🔥';
                    projectile.style.fontSize = '80px';
                    projectile.style.filter = `drop-shadow(0 0 40px ${config.colors[0]}) drop-shadow(0 0 80px ${config.colors[1]})`;
                    projectile.style.animation = 'fireball 0.6s linear infinite';
                    // 火の粒子トレイル追加
                    for (let i = 0; i < 5; i++) {
                        const trail = document.createElement('div');
                        trail.innerHTML = '🔥';
                        trail.style.position = 'absolute';
                        trail.style.fontSize = '20px';
                        trail.style.opacity = '0.6';
                        trail.style.left = `-${i * 15}px`;
                        trail.style.top = '0px';
                        trail.style.animation = `fireball ${0.6 + i * 0.1}s linear infinite`;
                        projectile.appendChild(trail);
                    }
                    break;
                    
                case 'water':
                    projectile.style.width = '120px';
                    projectile.style.height = '16px';
                    projectile.style.background = `linear-gradient(90deg, transparent, ${config.colors[0]}, ${config.colors[1]}, transparent)`;
                    projectile.style.borderRadius = '8px';
                    projectile.style.boxShadow = `0 0 30px ${config.colors[0]}, 0 0 60px ${config.colors[1]}`;
                    projectile.style.animation = 'waterBlade 0.5s ease-in-out infinite';
                    // 水滴エフェクト追加
                    for (let i = 0; i < 3; i++) {
                        const drop = document.createElement('div');
                        drop.innerHTML = '💧';
                        drop.style.position = 'absolute';
                        drop.style.fontSize = '24px';
                        drop.style.left = `${i * 30}px`;
                        drop.style.top = '-10px';
                        drop.style.animation = `waterBlade ${0.5 + i * 0.1}s ease-in-out infinite`;
                        projectile.appendChild(drop);
                    }
                    break;
                    
                case 'thunder':
                    projectile.innerHTML = '⚡';
                    projectile.style.fontSize = '100px';
                    projectile.style.filter = `drop-shadow(0 0 50px ${config.colors[1]}) drop-shadow(0 0 100px white)`;
                    projectile.style.animation = 'lightning 0.1s linear infinite';
                    // 電撃エフェクト追加
                    for (let i = 0; i < 4; i++) {
                        const bolt = document.createElement('div');
                        bolt.style.position = 'absolute';
                        bolt.style.width = '4px';
                        bolt.style.height = '60px';
                        bolt.style.background = config.colors[1];
                        bolt.style.left = `${Math.random() * 60 - 30}px`;
                        bolt.style.top = `${Math.random() * 60 - 30}px`;
                        bolt.style.transform = `rotate(${Math.random() * 360}deg)`;
                        bolt.style.boxShadow = `0 0 20px ${config.colors[1]}`;
                        bolt.style.animation = 'lightning 0.05s linear infinite';
                        projectile.appendChild(bolt);
                    }
                    break;
                    
                case 'wind':
                    projectile.innerHTML = '🌪️';
                    projectile.style.fontSize = '90px';
                    projectile.style.filter = `drop-shadow(0 0 30px ${config.colors[0]})`;
                    projectile.style.animation = 'windBlade 0.4s ease-out infinite';
                    // 風の渦エフェクト追加
                    for (let i = 0; i < 6; i++) {
                        const swirl = document.createElement('div');
                        swirl.style.position = 'absolute';
                        swirl.style.width = '20px';
                        swirl.style.height = '20px';
                        swirl.style.border = `2px solid ${config.colors[0]}`;
                        swirl.style.borderRadius = '50%';
                        swirl.style.left = `${Math.cos(i * Math.PI / 3) * 40}px`;
                        swirl.style.top = `${Math.sin(i * Math.PI / 3) * 40}px`;
                        swirl.style.animation = `windBlade ${0.4 + i * 0.05}s ease-out infinite`;
                        projectile.appendChild(swirl);
                    }
                    break;
                    
                case 'earth':
                    projectile.innerHTML = '🪨';
                    projectile.style.fontSize = '70px';
                    projectile.style.filter = `drop-shadow(0 0 20px ${config.colors[0]})`;
                    projectile.style.animation = 'rockSpike 0.3s ease-out infinite';
                    // 岩の破片エフェクト追加
                    for (let i = 0; i < 4; i++) {
                        const rock = document.createElement('div');
                        rock.innerHTML = '🪨';
                        rock.style.position = 'absolute';
                        rock.style.fontSize = '16px';
                        rock.style.left = `${(i % 2) * 40 - 20}px`;
                        rock.style.top = `${Math.floor(i / 2) * 40 - 20}px`;
                        rock.style.animation = `rockSpike ${0.3 + i * 0.1}s ease-out infinite`;
                        projectile.appendChild(rock);
                    }
                    break;
                    
case 'light': {
  const ring = document.createElement('div');
  ring.style.position = 'absolute';
  ring.style.left = (x - 100) + 'px';
  ring.style.top = (y - 100) + 'px';
  ring.style.width = '200px';
  ring.style.height = '200px';
  ring.style.border = `8px solid ${config.colors[0]}`;
  ring.style.borderRadius = '50%';
  ring.style.boxShadow = `0 0 60px ${config.colors[0]}, inset 0 0 60px white`;
  ring.style.opacity = '0.9';
  fxLayer.appendChild(ring);

  ring.animate(
    [{ transform:'scale(0.4)', opacity:0 }, { transform:'scale(4)', opacity:0 }],
    { duration: 900, easing:'ease-out' }
  ).addEventListener('finish', () => ring.remove());

  // 星粒
  for (let i = 0; i < Math.round(6 * getFXScale()); i++) {
    const star = document.createElement('div');
    star.textContent = '✨';
    star.style.position = 'absolute';
    star.style.left = x + 'px';
    star.style.top = y + 'px';
    star.style.fontSize = (16 + Math.random()*10) + 'px';
    fxLayer.appendChild(star);
    const dx = (Math.random()*2-1) * 240;
    const dy = (Math.random()*2-1) * 240;
    star.animate(
      [{ transform:'translate(0,0)', opacity:1 }, { transform:`translate(${dx}px,${dy}px)`, opacity:0 }],
      { duration: 800 + Math.random()*500, easing:'ease-out' }
    ).addEventListener('finish', () => star.remove());
  }
  break;
}
// ← switch の default/break と関数の閉じカッコまで忘れずに！


        // フェーズ3: ヒットエフェクト
        function playImpactEffect(fxLayer, attr, config, x, y) {
            return new Promise((resolve) => {
                // ヒット音
                playSound('success');
                
                // 画面シェイク
                if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    document.body.classList.add('shake-strong');
                    setTimeout(() => {
                        document.body.classList.remove('shake-strong');
                    }, 400);
                }
                
                // フラッシュエフェクト
                const flash = document.createElement('div');
                flash.className = 'impact-flash';
                flash.style.background = config.flashColor;
                flash.style.opacity = '0';
                fxLayer.appendChild(flash);
                
                flash.animate([
                    { opacity: 0 },
                    { opacity: 1 },
                    { opacity: 0 }
                ], {
                    duration: 200,
                    easing: 'ease-out'
                }).addEventListener('finish', () => {
                    flash.remove();
                });
                
                // パーティクル爆発
                createParticleExplosion(fxLayer, attr, config, x, y);
                
                // 属性別特殊エフェクト
                createSpecialImpactEffect(fxLayer, attr, config, x, y);
                
                setTimeout(resolve, 500);
            });
        }

        // パーティクル爆発生成（画面全体スケール）
        function createParticleExplosion(fxLayer, attr, config, x, y) {
            const particleCount = Math.round(Math.min(config.particles, 120) * getFXScale());
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                const size = Math.random() * 16 + 8; // より大きなパーティクル
                const angle = (i / particleCount) * Math.PI * 2;
                const distance = Math.random() * 300 + 100; // より広範囲に散らばる
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance;
                
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.left = (x - size/2) + 'px';
                particle.style.top = (y - size/2) + 'px';
                particle.style.background = config.colors[Math.floor(Math.random() * config.colors.length)];
                particle.style.borderRadius = '50%';
                particle.style.boxShadow = `0 0 ${size}px ${config.colors[0]}`;
                particle.style.setProperty('--dx', dx + 'px');
                particle.style.setProperty('--dy', dy + 'px');
                
                fxLayer.appendChild(particle);
                
                particle.animate([
                    { 
                        transform: 'scale(0) translate3d(0, 0, 0) rotate(0deg)',
                        opacity: 1
                    },
                    { 
                        transform: `scale(1.5) translate3d(${dx * 0.7}px, ${dy * 0.7}px, 0) rotate(180deg)`,
                        opacity: 0.8,
                        offset: 0.6
                    },
                    { 
                        transform: `scale(0.5) translate3d(${dx}px, ${dy}px, 0) rotate(360deg)`,
                        opacity: 0
                    }
                ], {
                    duration: 1200 + Math.random() * 600,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                }).addEventListener('finish', () => {
                    particle.remove();
                });
            }
        }

        // 属性別特殊インパクトエフェクト（画面全体スケール）
        function createSpecialImpactEffect(fxLayer, attr, config, x, y) {
            switch (attr) {
                case 'fire':
                    // 巨大火花リング
                    const fxScale = getFXScale();
                    for (let i = 0; i < Math.round(5 * fxScale); i++) {
                        const ring = document.createElement('div');
                        ring.style.position = 'absolute';
                        ring.style.left = (x - 100) + 'px';
                        ring.style.top = (y - 100) + 'px';
                        ring.style.width = '200px';
                        ring.style.height = '200px';
                        ring.style.border = `6px solid ${config.colors[0]}`;
                        ring.style.borderRadius = '50%';
                        ring.style.opacity = '0.8';
                        ring.style.boxShadow = `0 0 40px ${config.colors[0]}, inset 0 0 40px ${config.colors[1]}`;
                        fxLayer.appendChild(ring);
                        
                        ring.animate([
                            { transform: 'scale(0) rotate(0deg)', opacity: 0.8 },
                            { transform: 'scale(6) rotate(360deg)', opacity: 0 }
                        ], {
                            duration: 1000,
                            delay: i * 150,
                            easing: 'ease-out'
                        }).addEventListener('finish', () => ring.remove());
                    }
                    
                    // 火の柱エフェクト
                    const firePillar = document.createElement('div');
                    firePillar.style.position = 'absolute';
                    firePillar.style.left = (x - 50) + 'px';
                    firePillar.style.top = '0px';
                    firePillar.style.width = '100px';
                    firePillar.style.height = '100vh';
                    firePillar.style.background = `linear-gradient(0deg, transparent, ${config.colors[0]}, ${config.colors[1]}, transparent)`;
                    firePillar.style.opacity = '0.6';
                    fxLayer.appendChild(firePillar);
                    
                    firePillar.animate([
                        { opacity: 0, transform: 'scaleX(0)' },
                        { opacity: 0.6, transform: 'scaleX(1)' },
                        { opacity: 0, transform: 'scaleX(0)' }
                    ], {
                        duration: 800,
                        easing: 'ease-out'
                    }).addEventListener('finish', () => firePillar.remove());
                    break;
                    
                case 'water':
                    // 巨大水のリップル
                    const waterFxScale = getFXScale();
                    for (let i = 0; i < Math.round(4 * waterFxScale); i++) {
                        const ripple = document.createElement('div');
                        ripple.style.position = 'absolute';
                        ripple.style.left = (x - 150) + 'px';
                        ripple.style.top = (y - 150) + 'px';
                        ripple.style.width = '300px';
                        ripple.style.height = '300px';
                        ripple.style.border = `8px solid ${config.colors[1]}`;
                        ripple.style.borderRadius = '50%';
                        ripple.style.opacity = '0.7';
                        ripple.style.boxShadow = `0 0 60px ${config.colors[0]}`;
                        fxLayer.appendChild(ripple);
                        
                        ripple.animate([
                            { transform: 'scale(0)', opacity: 0.7 },
                            { transform: 'scale(8)', opacity: 0 }
                        ], {
                            duration: 1200,
                            delay: i * 250,
                            easing: 'ease-out'
                        }).addEventListener('finish', () => ripple.remove());
                    }
                    
                    // 水の波エフェクト
                    const wave = document.createElement('div');
                    wave.style.position = 'absolute';
                    wave.style.left = '0px';
                    wave.style.top = (y - 25) + 'px';
                    wave.style.width = '100vw';
                    wave.style.height = '50px';
                    wave.style.background = `linear-gradient(90deg, transparent, ${config.colors[0]}, ${config.colors[1]}, transparent)`;
                    wave.style.opacity = '0.5';
                    fxLayer.appendChild(wave);
                    
                    wave.animate([
                        { opacity: 0, transform: 'scaleY(0)' },
                        { opacity: 0.5, transform: 'scaleY(1)' },
                        { opacity: 0, transform: 'scaleY(0)' }
                    ], {
                        duration: 600,
                        easing: 'ease-out'
                    }).addEventListener('finish', () => wave.remove());
                    break;
                    
                case 'thunder':
                    // 巨大電撃アーク
                    const thunderFxScale = getFXScale();
                    for (let i = 0; i < Math.round(8 * thunderFxScale); i++) {
                        const arc = document.createElement('div');
                        arc.style.position = 'absolute';
                        arc.style.left = x + 'px';
                        arc.style.top = y + 'px';
                        arc.style.width = '8px';
                        arc.style.height = (Math.random() * 200 + 100) + 'px';
                        arc.style.background = config.colors[1];
                        arc.style.transformOrigin = 'top';
                        arc.style.transform = `rotate(${Math.random() * 360}deg)`;
                        arc.style.boxShadow = `0 0 40px ${config.colors[1]}, 0 0 80px white`;
                        fxLayer.appendChild(arc);
                        
                        arc.animate([
                            { opacity: 1, transform: `rotate(${Math.random() * 360}deg) scaleY(1)` },
                            { opacity: 0, transform: `rotate(${Math.random() * 360}deg) scaleY(0)` }
                        ], {
                            duration: 400,
                            delay: Math.random() * 300,
                            easing: 'ease-out'
                        }).addEventListener('finish', () => arc.remove());
                    }
                    
                    // 画面全体の電撃フラッシュ
                    const lightning = document.createElement('div');
                    lightning.style.position = 'absolute';
                    lightning.style.left = '0px';
                    lightning.style.top = '0px';
                    lightning.style.width = '100vw';
                    lightning.style.height = '100vh';
                    lightning.style.background = `radial-gradient(circle at ${x}px ${y}px, ${config.colors[1]} 0%, transparent 50%)`;
                    lightning.style.opacity = '0';
                    fxLayer.appendChild(lightning);
                    
                    lightning.animate([
                        { opacity: 0 },
                        { opacity: 0.8 },
                        { opacity: 0 },
                        { opacity: 0.6 },
                        { opacity: 0 }
                    ], {
                        duration: 500,
                        easing: 'ease-out'
                    }).addEventListener('finish', () => lightning.remove());
                    break;
                    
                case 'wind':
                    // 巨大竜巻エフェクト
                    const windFxScale = getFXScale();
                    for (let i = 0; i < Math.round(3 * windFxScale); i++) {
                        const tornado = document.createElement('div');
                        tornado.style.position = 'absolute';
                        tornado.style.left = (x - 75) + 'px';
                        tornado.style.top = '0px';
                        tornado.style.width = '150px';
                        tornado.style.height = '100vh';
                        tornado.style.background = `conic-gradient(from ${i * 120}deg, transparent, ${config.colors[0]}, transparent)`;
                        tornado.style.opacity = '0.4';
                        tornado.style.borderRadius = '50%';
                        fxLayer.appendChild(tornado);
                        
                        tornado.animate([
                            { transform: 'rotate(0deg) scaleX(0)', opacity: 0 },
                            { transform: 'rotate(720deg) scaleX(1)', opacity: 0.4 },
                            { transform: 'rotate(1440deg) scaleX(0)', opacity: 0 }
                        ], {
                            duration: 1000,
                            delay: i * 200,
                            easing: 'ease-out'
                        }).addEventListener('finish', () => tornado.remove());
                    }
                    break;
                    
                case 'earth':
                    // 地面全体の亀裂エフェクト
                    const earthFxScale = getFXScale();
                    for (let i = 0; i < Math.round(6 * earthFxScale); i++) {
                        const crack = document.createElement('div');
                        crack.style.position = 'absolute';
                        crack.style.left = '0px';
                        crack.style.top = (y + Math.random() * 100 - 50) + 'px';
                        crack.style.width = '100vw';
                        crack.style.height = '4px';
                        crack.style.background = config.colors[2] || config.colors[0];
                        crack.style.opacity = '0.8';
                        crack.style.transform = `rotate(${Math.random() * 10 - 5}deg)`;
                        fxLayer.appendChild(crack);
                        
                        crack.animate([
                            { transform: `scaleX(0) rotate(${Math.random() * 10 - 5}deg)`, opacity: 0 },
                            { transform: `scaleX(1) rotate(${Math.random() * 10 - 5}deg)`, opacity: 0.8 },
                            { transform: `scaleX(1) rotate(${Math.random() * 10 - 5}deg)`, opacity: 0 }
                        ], {
                            duration: 800,
                            delay: i * 100,
                            easing: 'ease-out'
                        }).addEventListener('finish', () => crack.remove());
                    }
                    break;
                    
                                case 'light': {
                    // シンプルな星型バースト＋外周リング（仮実装でも十分映える）
                    const ring = document.createElement('div');
                    ring.style.position = 'absolute';
                    ring.style.left = (x - 100) + 'px';
                    ring.style.top = (y - 100) + 'px';
                    ring.style.width = '200px';
                    ring.style.height = '200px';
                    ring.style.borderRadius = '50%';
                    ring.style.boxShadow = `0 0 60px ${config.colors[0]}, inset 0 0 40px white`;
                    ring.style.opacity = '0.9';
                    fxLayer.appendChild(ring);

                    ring.animate(
                        [{ transform: 'scale(0)', opacity: 1 },
                         { transform: 'scale(5)', opacity: 0 }],
                        { duration: 700, easing: 'ease-out' }
                    ).addEventListener('finish', () => ring.remove());

                    // 光の星粒を四方に
                    for (let i = 0; i < 24; i++) {
                        const p = document.createElement('div');
                        p.textContent = '✨';
                        p.style.position = 'absolute';
                        p.style.left = x + 'px';
                        p.style.top = y + 'px';
                        p.style.fontSize = (16 + Math.random() * 10) + 'px';
                        p.style.filter = 'drop-shadow(0 0 8px white)';
                        fxLayer.appendChild(p);

                        const ang = (i / 24) * Math.PI * 2;
                        const dist = 160 + Math.random() * 120;
                        const dx = Math.cos(ang) * dist;
                        const dy = Math.sin(ang) * dist;

                        p.animate(
                            [{ transform: 'translate(0,0) scale(0.8)', opacity: 1 },
                             { transform: `translate(${dx}px, ${dy}px) scale(1.2)`, opacity: 0 }],
                            { duration: 800 + Math.random() * 300, easing: 'ease-out' }
                        ).addEventListener('finish', () => p.remove());
                    }
                    break;
                }
            } // ← switch(attr) の閉じ
        } // ← function createSpecialImpactEffect の閉じ


        // 被弾エフェクト（不正解時）
        function playHitEffect(playerIndex) {
            const avatarEl = document.getElementById(`player${playerIndex + 1}Avatar`);
            const fxLayer = getOrCreateFxLayer();
            
            // 煙エフェクト
            const smoke = document.createElement('div');
            smoke.innerHTML = '💨';
            smoke.style.position = 'absolute';
            smoke.style.fontSize = '30px';
            smoke.style.opacity = '0.8';
            
            const rect = avatarEl.getBoundingClientRect();
            smoke.style.left = rect.left + 'px';
            smoke.style.top = rect.top + 'px';
            
            fxLayer.appendChild(smoke);
            
            smoke.animate([
                { transform: 'scale(0.5) translateY(0)', opacity: 0.8 },
                { transform: 'scale(1.5) translateY(-30px)', opacity: 0 }
            ], {
                duration: 600,
                easing: 'ease-out'
            }).addEventListener('finish', () => smoke.remove());
            
            // 赤フラッシュ
            const flash = document.createElement('div');
            flash.className = 'impact-flash';
            flash.style.background = 'rgba(255, 107, 107, 0.4)';
            fxLayer.appendChild(flash);
            
            flash.animate([
                { opacity: 0 },
                { opacity: 1 },
                { opacity: 0 }
            ], {
                duration: 300,
                easing: 'ease-out'
            }).addEventListener('finish', () => flash.remove());
        }

        // HP管理の統一関数（事故防止）
        function setHp(playerIndex, value) {
            const player = gameState.players[playerIndex];
            player.hp = Math.max(0, Math.min(player.maxHp, value));
            updateUI();
        }

        function addHp(playerIndex, delta) {
            setHp(playerIndex, gameState.players[playerIndex].hp + delta);
        }

        // ペナルティエフェクト表示
        function showPenaltyEffect() {
            const timerRing = document.getElementById('timerRing');
            const penaltyElement = document.createElement('div');
            penaltyElement.className = 'damage-number';
            penaltyElement.textContent = '-2秒';
            penaltyElement.style.left = '50%';
            penaltyElement.style.top = '20%';
            penaltyElement.style.color = '#ff6b6b';
            penaltyElement.style.fontSize = '20px';
            
            timerRing.style.position = 'relative';
            timerRing.appendChild(penaltyElement);
            
            // タイマーリングを赤く点滅とシェイク
            timerRing.style.boxShadow = '0 0 20px rgba(255, 107, 107, 0.8)';
            timerRing.classList.add('shake');
            setTimeout(() => {
                timerRing.style.boxShadow = '';
                timerRing.classList.remove('shake');
                if (penaltyElement.parentNode) {
                    penaltyElement.remove();
                }
            }, 1000);
        }

        // 時間切れ
        function timeUp() {
            if (!gameState.selectedCard || gameState.gamePhase !== 'typing') return;
            
            // 入力ハンドラーを即座に無効化
            disableTyping();
            clearTypingDisplay();
            
            // 統計更新
            const targetLen = countChars(gameState.selectedCard.text);
            const currentPlayerIndex = gameState.currentPlayer;
            
            gameState.playerStats[currentPlayerIndex].totalChars += targetLen;
            gameState.playerStats[currentPlayerIndex].totalTime += 12;
            gameState.playerStats[currentPlayerIndex].combo = 0;
            
            // 全体統計も更新
            gameState.stats.totalChars += targetLen;
            gameState.stats.totalTime += 12;
            gameState.stats.combo = 0;
            
            // 集約ロジックへ（失敗扱い）
            applyResult({ success: false });
        }

        // ギブアップ
        function giveUp() {
            if (!gameState.selectedCard) return;
            
            // 入力ハンドラーを即座に無効化
            disableTyping();
            clearTypingDisplay();
            
            // 統計更新
            const targetLen = countChars(gameState.selectedCard.text);
            const timeUsed = Math.max(0, 12 - gameState.timer);
            const currentPlayerIndex = gameState.currentPlayer;
            
            gameState.playerStats[currentPlayerIndex].totalChars += targetLen;
            gameState.playerStats[currentPlayerIndex].totalTime += timeUsed;
            gameState.playerStats[currentPlayerIndex].combo = 0;
            
            // 全体統計も更新
            gameState.stats.totalChars += targetLen;
            gameState.stats.totalTime += timeUsed;
            gameState.stats.combo = 0;
            
            applyResult({ success: false });
        }

        // 音声再生
        function playSound(type) {
            if (!gameState.soundEnabled) return;
            
            ensureAudio();
            if (!audioCtx) return;
            
            // 確実な起動のため再生直前でもresume
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            // 簡易音声（実際の実装では適切な音声ファイルを使用）
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'success') {
                oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.1); // E5
            } else if (type === 'attack') {
                // 攻撃音：力強い低音から高音へ
                oscillator.frequency.setValueAtTime(150, audioCtx.currentTime); // 低音
                oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.2);
                oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.4);
            } else if (type === 'heal') {
                // 回復音：美しい和音
                oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioCtx.currentTime + 0.2); // G5
                oscillator.frequency.setValueAtTime(1046.50, audioCtx.currentTime + 0.3); // C6
            } else if (type === 'charge') {
                // 溜め音：低音から高音へ
                oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.3);
            } else if (type === 'fail') {
                oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); // A3
                oscillator.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.3); // 下降
            } else {
                oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); // A3
            }
            
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (type === 'heal' ? 0.5 : type === 'attack' ? 0.4 : 0.3));
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + (type === 'heal' ? 0.5 : type === 'attack' ? 0.4 : 0.3));
        }

        // ゲーム一時停止
        function pauseGame() {
            if (gameState.gamePhase !== 'typing') return;

            if (!gameState.isPaused) {
                gameState.isPaused = true;
                stopTimer(); // rAF停止でCPU消費を抑制
                document.getElementById('pauseBtn').textContent = '▶️';
                showModal('⏸️ 一時停止', `
                    <p>ゲームを一時停止しました</p>
                    <button class="btn btn-primary" onclick="resumeGame()">再開</button>
                `);
            } else {
                resumeGame();
            }
        }

        // ゲーム再開
        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseBtn').textContent = '⏸️';
            hideModal();
            // 期限は保持してあるので残り時間で再開
            const remainingMs = Math.max(0, timerDeadline - performance.now());
            if (remainingMs > 0) {
                startAccurateTimer(remainingMs);
            }
        }

        // メニューに戻る
        function backToMenu() {
            // ゲーム状態リセット
            gameState = {
                mode: null,
                maxHP: 200,
                players: [
                    { name: 'プレイヤー1', hp: 200, maxHp: 200, avatar: '🔥', attribute: 'fire' },
                    { name: 'CPU', hp: 200, maxHp: 200, avatar: '🤖', attribute: 'water' }
                ],
                currentPlayer: 0,
                selectedCard: null,
                hands: [[], []],
                deck: [],
                discard: [],
                timer: 15,
                timerInterval: null,
                gamePhase: 'cardSelect',
                soundEnabled: true,
                isPaused: false,
                playerStats: [
                    { totalChars: 0, correctChars: 0, totalTime: 0, combo: 0, maxCombo: 0 },
                    { totalChars: 0, correctChars: 0, totalTime: 0, combo: 0, maxCombo: 0 }
                ],
                stats: {
                    totalChars: 0,
                    correctChars: 0,
                    totalTime: 0,
                    combo: 0,
                    maxCombo: 0
                }
            };
            
            stopTimer();
            disableTyping();
            hideModal();
            document.getElementById('gameContainer').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('characterSelection').classList.add('hidden');
            document.getElementById('gameRules').classList.add('hidden');
            document.getElementById('player2Setup').classList.add('hidden');
            
            // 選択状態をリセット
            document.querySelectorAll('.mode-btn, .character-btn, .hp-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // デフォルトHP選択
            document.querySelector('[data-hp="200"]').classList.add('selected');
            
            // 名前入力をリセット
            document.getElementById('player1NameInput').value = 'プレイヤー1';
            document.getElementById('player2NameInput').value = 'プレイヤー2';
            document.getElementById('nextBtn').disabled = true;
        }

        // ターン開始
        function startTurn() {
            showTurnPopup(gameState.players[gameState.currentPlayer].name);
            updateUI();
            
            // カード表示エリアを完全にクリア
            const container = document.getElementById('cardsContainer');
            container.innerHTML = '';
            container.classList.remove('active');
            
            // タイピングガイドもクリア
            clearTypingDisplay();
            
            // 新しいカードを描画
            drawCards();
            drawPlayerHand();
            
            // タイマーリセット
            document.getElementById('timerRing').textContent = '12';
            document.getElementById('timerRing').style.background = 
                'conic-gradient(#feca57 360deg, rgba(255, 255, 255, 0.2) 360deg)';
            
            // CPU判定
            if (gameState.mode === 'cpu' && gameState.currentPlayer === 1) {
                setTimeout(cpuAct, 700);
            }
        }

        // 結果適用ユーティリティ
        async function applyResult({ success }) {
            const card = gameState.selectedCard;
            const isHeal = card?.category === 'いりょう';
            const baseLen = countChars(card?.text || '');
            const atk = gameState.currentPlayer;
            const def = 1 - atk;

            // 入力/タイマー停止を先に片付け
            disableTyping();
            stopTimer();

            let amount = 0;
            let effectDuration = 0; // エフェクトの待機時間

            if (success) {
                amount = baseLen * Math.max(0, gameState.timer); // 成功：文字数×残り秒
                if (isHeal) {
                    // 計算ポップアップ表示（回復）
                    showDamageCalculation(baseLen, gameState.timer, amount, true, false);
                    
                    addHp(atk, amount);
                    playSound('heal');
                    showFloatingNumber(amount, atk, true);
                    effectDuration = 1000; // 回復エフェクトの時間
                } else {
                    // 計算ポップアップ表示（攻撃）
                    showDamageCalculation(baseLen, gameState.timer, amount, false, false);
                    
                    addHp(def, -amount);
                    playSound('attack');
                    const targetEl = document.getElementById(`player${def+1}Avatar`);
                    // 攻撃アニメーションを待つ
                    await playAttackAnimation({ attr: gameState.players[atk].attribute, from: atk===0?'left':'right', targetEl });
                    showFloatingNumber(amount, def, false);
                    effectDuration = 800; // 攻撃エフェクトの余韻時間
                }
            } else {
                amount = baseLen * 5; // 失敗：自傷
                
                // 計算ポップアップ表示（自傷）
                showDamageCalculation(baseLen, 0, amount, false, true);
                
                addHp(atk, -amount);
                playSound('fail');
                playHitEffect(atk);
                showFloatingNumber(amount, atk, false);
                effectDuration = 600; // 失敗エフェクトの時間
            }

            // 選んだカードを捨て＆補充
            const hand = gameState.hands[atk];
            const idx = hand.indexOf(card);
            if (idx > -1) hand.splice(idx, 1);
            if (gameState.deck.length > 0 && hand.length < 6) hand.push(gameState.deck.pop());

            // 片付け
            gameState.selectedCard = null;

            // タイピング表示をクリア
            clearTypingDisplay();

            // HP/UIの即時更新
            updateUI();

            // 勝敗チェック（ここで確定終了）
            const p0Dead = gameState.players[0].hp <= 0;
            const p1Dead = gameState.players[1].hp <= 0;
            if (p0Dead || p1Dead) {
                const winner = p0Dead && p1Dead ? null : (p0Dead ? 1 : 0);
                // エフェクト完了を待ってからゲーム終了
                setTimeout(() => {
                    endGame(winner);
                }, effectDuration);
                return;
            }

            // エフェクト完了を待ってからターン交代
            setTimeout(() => {
                // ★ここでターン交代してから描画★
                gameState.currentPlayer = def;
                gameState.gamePhase = 'cardSelect';

                // 次手番の手札/カード描画（交代後！）
                drawPlayerHand();
                drawCards();

                // 表示文言更新＆ターン告知
                updateUI();
                showTurnPopup(gameState.players[gameState.currentPlayer].name);
            }, effectDuration);
        }

        // 浮遊ダメージ数値表示
        function showFloatingNumber(num, playerIndex, isHeal){
            const target = document.getElementById(`player${playerIndex+1}Avatar`);
            const rect = target.getBoundingClientRect();
            const n = document.createElement('div');
            n.className = 'damage-number' + (isHeal?' heal':'');
            n.style.left = rect.left + rect.width/2 + 'px';
            n.style.top  = rect.top  + 'px';
            n.textContent = (isHeal?'+':'-') + num;
            document.body.appendChild(n);
            setTimeout(()=> n.remove(), 1600);
        }

        // ダメージ計算ポップアップ表示
        function showDamageCalculation(charCount, remainingTime, totalDamage, isHeal = false, isSelfDamage = false) {
            const popup = document.createElement('div');
            popup.className = 'damage-calculation-popup';
            
            let formula, description;
            if (isSelfDamage) {
                formula = `${charCount}文字 × 5 = ${totalDamage}ダメージ`;
                description = '失敗による自傷ダメージ';
            } else if (isHeal) {
                formula = `${charCount}文字 × 残り${remainingTime}秒 = ${totalDamage}回復`;
                description = '医療カードによる回復';
            } else {
                formula = `${charCount}文字 × 残り${remainingTime}秒 = ${totalDamage}ダメージ`;
                description = '攻撃カードによるダメージ';
            }
            
            popup.innerHTML = `
                <div class="calculation-content ${isHeal ? 'heal' : isSelfDamage ? 'self-damage' : 'attack'}">
                    <div class="calculation-icon">${isHeal ? '💚' : isSelfDamage ? '💥' : '⚔️'}</div>
                    <div class="calculation-formula">${formula}</div>
                    <div class="calculation-description">${description}</div>
                </div>
            `;
            
            document.body.appendChild(popup);
            
            // アニメーション後に削除
            setTimeout(() => {
                popup.remove();
            }, 5000);
        }

        // 答え送信
        function submitAnswer() {
            if (!gameState.selectedCard) return;
            
            // 入力ハンドラーを即座に無効化
            disableTyping();
            clearTypingDisplay();
            
            // 統計更新（現在のプレイヤー用）
            const targetLen = countChars(gameState.selectedCard.text);
            const timeUsed = Math.max(0, 12 - gameState.timer);
            const currentPlayerIndex = gameState.currentPlayer;
            
            gameState.playerStats[currentPlayerIndex].totalChars += targetLen;
            gameState.playerStats[currentPlayerIndex].totalTime += timeUsed;
            
            // 全体統計も更新（後方互換性のため）
            gameState.stats.totalChars += targetLen;
            gameState.stats.totalTime += timeUsed;
            
            // いずれかの候補が完了していれば成功
            const success = typingState.currentInputs.some(input => input.completed);
            
            if (success) {
                gameState.playerStats[currentPlayerIndex].correctChars += targetLen;
                gameState.playerStats[currentPlayerIndex].combo++;
                gameState.playerStats[currentPlayerIndex].maxCombo = Math.max(
                    gameState.playerStats[currentPlayerIndex].maxCombo, 
                    gameState.playerStats[currentPlayerIndex].combo
                );
                
                // 全体統計も更新
                gameState.stats.correctChars += targetLen;
                gameState.stats.combo++;
                gameState.stats.maxCombo = Math.max(gameState.stats.maxCombo, gameState.stats.combo);
            } else {
                gameState.playerStats[currentPlayerIndex].combo = 0;
                gameState.stats.combo = 0;
            }
            
            applyResult({ success });
        }

        // 時間切れ
        function timeUp() {
            if (!gameState.selectedCard) return;
            
            // 統計更新
            const targetLen = countChars(gameState.selectedCard.text);
            gameState.stats.totalChars += targetLen;
            gameState.stats.totalTime += 12;
            gameState.stats.combo = 0;
            
            applyResult({ success: false });
        }

        // ギブアップ
        function giveUp() {
            if (!gameState.selectedCard) return;
            
            // 入力ハンドラーを即座に無効化
            disableTyping();
            clearTypingDisplay();
            
            // 統計更新
            const targetLen = countChars(gameState.selectedCard.text);
            const timeUsed = Math.max(0, 12 - gameState.timer);
            gameState.stats.totalChars += targetLen;
            gameState.stats.totalTime += timeUsed;
            gameState.stats.combo = 0;
            
            applyResult({ success: false });
        }

        // 時間切れ
        function timeUp() {
            if (!gameState.selectedCard || gameState.gamePhase !== 'typing') return;
            
            // 入力ハンドラーを即座に無効化
            disableTyping();
            clearTypingDisplay();
            // 統計
            const targetLen = countChars(gameState.selectedCard.text);
            gameState.stats.totalChars += targetLen;
            gameState.stats.totalTime += 12;
            gameState.stats.combo = 0;
            // 集約ロジックへ（失敗扱い）
            applyResult({ success: false });
        }

        // ダメージ処理
        function dealDamage(playerIndex, damage) {
            gameState.players[playerIndex].hp = Math.max(0, gameState.players[playerIndex].hp - damage);
            
            // ダメージエフェクト
            showDamageEffect(playerIndex, damage);
            
            // HP更新
            updateUI();
            
            // 勝敗判定
            if (gameState.players[playerIndex].hp <= 0) {
                endGame(1 - playerIndex);
            }
        }

        // 回復処理
        function healPlayer(playerIndex, healAmount) {
            const player = gameState.players[playerIndex];
            const actualHeal = Math.min(healAmount, player.maxHp - player.hp);
            player.hp = Math.min(player.maxHp, player.hp + actualHeal);
            
            // 回復エフェクト
            showHealEffect(playerIndex, actualHeal);
            
            // HP更新
            updateUI();
        }

        // ダメージエフェクト表示
        function showDamageEffect(playerIndex, damage) {
            const avatar = document.getElementById(`player${playerIndex + 1}Avatar`);
            const damageElement = document.createElement('div');
            damageElement.className = 'damage-number';
            damageElement.textContent = `-${damage}`;
            damageElement.style.left = '50%';
            damageElement.style.top = '50%';
            
            avatar.style.position = 'relative';
            avatar.appendChild(damageElement);
            
            // シェイクエフェクト
            avatar.classList.add('shake');
            setTimeout(() => {
                avatar.classList.remove('shake');
                if (damageElement.parentNode) {
                    damageElement.remove();
                }
            }, 1000);
        }

        // 回復エフェクト表示
        function showHealEffect(playerIndex, healAmount) {
            const avatar = document.getElementById(`player${playerIndex + 1}Avatar`);
            const healElement = document.createElement('div');
            healElement.className = 'damage-number heal';
            healElement.textContent = `+${healAmount}`;
            healElement.style.left = '50%';
            healElement.style.top = '50%';
            healElement.style.color = '#4ecdc4';
            
            avatar.style.position = 'relative';
            avatar.appendChild(healElement);
            
            // 回復の光エフェクト
            avatar.style.boxShadow = '0 0 30px rgba(76, 220, 196, 0.8)';
            avatar.style.transform = 'scale(1.1)';
            
            setTimeout(() => {
                avatar.style.boxShadow = '';
                avatar.style.transform = '';
                if (healElement.parentNode) {
                    healElement.remove();
                }
            }, 1000);
            
            // 回復パーティクル
            createHealParticles(avatar);
        }

        // 回復パーティクル生成
        function createHealParticles(avatarEl) {
            const fxLayer = getOrCreateFxLayer();
            const rect = avatarEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.innerHTML = '✨';
                particle.style.position = 'absolute';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.fontSize = '20px';
                particle.style.color = '#4ecdc4';
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '1000';
                
                const angle = (i / 12) * Math.PI * 2;
                const distance = 60;
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance;
                
                fxLayer.appendChild(particle);
                
                particle.animate([
                    { 
                        transform: 'translate(-50%, -50%) scale(0)',
                        opacity: 1
                    },
                    { 
                        transform: `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(1.5)`,
                        opacity: 0.8,
                        offset: 0.7
                    },
                    { 
                        transform: `translate(calc(-50% + ${dx * 1.5}px), calc(-50% + ${dy * 1.5}px)) scale(0)`,
                        opacity: 0
                    }
                ], {
                    duration: 1000,
                    easing: 'ease-out'
                }).addEventListener('finish', () => {
                    particle.remove();
                });
            }
        }

        // ペナルティエフェクト表示
        function showPenaltyEffect() {
            const timerRing = document.getElementById('timerRing');
            const penaltyElement = document.createElement('div');
            penaltyElement.className = 'damage-number';
            penaltyElement.textContent = '-2秒';
            penaltyElement.style.left = '50%';
            penaltyElement.style.top = '20%';
            penaltyElement.style.color = '#ff6b6b';
            penaltyElement.style.fontSize = '20px';
            
            timerRing.style.position = 'relative';
            timerRing.appendChild(penaltyElement);
            
            // タイマーリングを赤く点滅とシェイク
            timerRing.style.boxShadow = '0 0 20px rgba(255, 107, 107, 0.8)';
            timerRing.classList.add('shake');
            setTimeout(() => {
                timerRing.style.boxShadow = '';
                timerRing.classList.remove('shake');
                if (penaltyElement.parentNode) {
                    penaltyElement.remove();
                }
            }, 1000);
        }



        // ターン開始
        function startTurn() {
            showTurnPopup(gameState.players[gameState.currentPlayer].name);
            updateUI();
            
            // カード表示エリアを完全にクリア
            const container = document.getElementById('cardsContainer');
            container.innerHTML = '';
            container.classList.remove('active');
            
            // タイピングガイドもクリア
            document.getElementById('typingGuideJP').textContent = '';
            document.getElementById('typingGuideJP').style.setProperty('--fill', '0%');
            document.getElementById('typingGuideSub').innerHTML = '';
            document.getElementById('romajiGuide').innerHTML = '';
            
            // 新しいカードを描画
            drawCards();
            drawPlayerHand();
            
            // タイマーリセット
            document.getElementById('timerRing').textContent = '12';
            document.getElementById('timerRing').style.background = 
                'conic-gradient(#feca57 360deg, rgba(255, 255, 255, 0.2) 360deg)';
            
            // CPU判定
            if (gameState.mode === 'cpu' && gameState.currentPlayer === 1) {
                setTimeout(cpuAct, 700);
            }
        }

        // ターン切り替えポップアップ表示
        function showTurnPopup(name) {
            // 既存のダメージ計算ポップアップを削除
            document.querySelectorAll('.damage-calculation-popup').forEach(popup => {
                popup.remove();
            });
            
            const div = document.createElement('div');
            div.className = 'turn-popup';
            
            const content = document.createElement('div');
            content.className = 'turn-popup-content';
            
            const title = document.createElement('h2');
            title.textContent = `${name}のターン`;
            
            const subtitle = document.createElement('div');
            subtitle.className = 'turn-popup-subtitle';
            subtitle.textContent = 'カードを選択してください';
            
            content.appendChild(title);
            content.appendChild(subtitle);
            div.appendChild(content);
            
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 2500);
        }

        // CPU行動
        async function cpuAct() {
            const hand = gameState.hands[1];
            const pick = hand.reduce((a, b) => a.difficulty <= b.difficulty ? a : b, hand[0]); // 簡単目
            gameState.selectedCard = pick;
            // 90% 成功くらいの確率で
            const success = Math.random() < 0.9;
            gameState.timer = Math.floor(4 + Math.random() * 8); // 残秒を適当に
            
            // 統計更新（CPU用）
            const targetLen = countChars(pick.text);
            const timeUsed = (TURN_MS / 1000) - gameState.timer;
            
            gameState.playerStats[1].totalChars += targetLen;
            gameState.playerStats[1].totalTime += timeUsed;
            
            // 全体統計も更新
            gameState.stats.totalChars += targetLen;
            gameState.stats.totalTime += timeUsed;
            
            if (success) {
                gameState.playerStats[1].correctChars += targetLen;
                gameState.playerStats[1].combo++;
                gameState.playerStats[1].maxCombo = Math.max(gameState.playerStats[1].maxCombo, gameState.playerStats[1].combo);
                
                // 全体統計も更新
                gameState.stats.correctChars += targetLen;
                gameState.stats.combo++;
                gameState.stats.maxCombo = Math.max(gameState.stats.maxCombo, gameState.stats.combo);
            } else {
                gameState.playerStats[1].combo = 0;
                gameState.stats.combo = 0;
            }
            
            await applyResult({ success });
        }

        // CPUターン
        async function cpuTurn() {
            updateUI();
            drawCards(); // ★追加：CPUもちゃんと1枚引く
            drawPlayerHand(); // 手札表示も更新
            
            setTimeout(async () => {
                // CPUカード選択（簡易AI）
                const hand = gameState.hands[1];
                let bestCard = hand[0];
                let bestScore = -1;
                
                hand.forEach(card => {
                    // 期待ダメージ計算（簡易）
                    const expectedTime = Math.random() * 10 + 5; // 5-15秒
                    const expectedDamage = card.text.length * expectedTime;
                    const failRisk = card.difficulty * 20; // 難易度による失敗リスク
                    const score = expectedDamage - failRisk;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestCard = card;
                    }
                });
                
                gameState.selectedCard = bestCard;
                
                // CPU入力シミュレーション
                setTimeout(async () => {
                    const success = Math.random() > (bestCard.difficulty * 0.2); // 難易度による成功率
                    
                    if (success) {
                        const cpuRemainingTime = Math.random() * 8 + 2; // 2-10秒残り時間
                        const charCount = countChars(bestCard.text);
                        const isHealCard = bestCard.category === 'いりょう';
                        
                        console.log(`CPU: 文字数=${charCount}, 残り時間=${cpuRemainingTime.toFixed(1)}秒`);
                        
                        if (isHealCard) {
                            // CPU回復処理
                            const healAmount = Math.floor(charCount * cpuRemainingTime);
                            console.log(`CPU回復計算: ${charCount} × ${cpuRemainingTime.toFixed(1)} = ${healAmount}`);
                            healPlayer(1, healAmount);
                            playSound('heal');
                        } else {
                            // CPU攻撃処理
                            const damage = Math.floor(charCount * cpuRemainingTime);
                            console.log(`CPU攻撃計算: ${charCount} × ${cpuRemainingTime.toFixed(1)} = ${damage}`);
                            
                            // CPU攻撃アニメーション
                            await playAttackAnimation({
                                attr: gameState.players[1].attribute,
                                from: 'right',
                                targetEl: document.getElementById('player1Avatar'),
                                impactMs: 600
                            });
                            
                            dealDamage(0, damage);
                        }
                        
                        gameState.stats.correctChars += charCount;
                        gameState.stats.totalChars += charCount;
                        gameState.stats.totalTime += (12 - cpuRemainingTime);
                    } else {
                        const charCount = countChars(bestCard.text);
                        const selfDamage = charCount * 5;
                        
                        console.log(`CPU自傷ダメージ計算: ${charCount} × 10 = ${selfDamage}`);
                        
                        // CPU被弾エフェクト
                        playHitEffect(1);
                        dealDamage(1, selfDamage);
                        
                        gameState.stats.totalChars += charCount;
                        gameState.stats.totalTime += 12;
                        
                        playSound('fail');
                    }
                    
                    endTurn();
                }, 2000);
            }, 1000);
        }

        // ゲーム終了
        function endGame(winnerIndex) {
            stopTimer();
            disableTyping();
            gameState.gamePhase = 'ended';
            gameState.selectedCard = null;

            // カードクリックを実質無効化
            const container = document.getElementById('cardsContainer');
            if (container) container.innerHTML = '';

            // 両プレイヤーの統計計算
            const player1Stats = gameState.playerStats[0] || { totalChars: 0, correctChars: 0, totalTime: 0, maxCombo: 0 };
            const player2Stats = gameState.playerStats[1] || { totalChars: 0, correctChars: 0, totalTime: 0, maxCombo: 0 };
            
            const p1Accuracy = player1Stats.totalChars > 0 ? 
                Math.round((player1Stats.correctChars / player1Stats.totalChars) * 100) : 0;
            const p1Speed = player1Stats.totalTime > 0 ? 
                Math.round((player1Stats.correctChars / player1Stats.totalTime) * 60) : 0;
                
            const p2Accuracy = player2Stats.totalChars > 0 ? 
                Math.round((player2Stats.correctChars / player2Stats.totalChars) * 100) : 0;
            const p2Speed = player2Stats.totalTime > 0 ? 
                Math.round((player2Stats.correctChars / player2Stats.totalTime) * 60) : 0;

            // モーダル表示
            const modal = document.getElementById('modal');
            const content = document.getElementById('modalContent');
            const isDraw = winnerIndex === null;
            const title = isDraw ? '引き分け！' : `勝者：${gameState.players[winnerIndex].name}`;
            const msg   = isDraw ? '両者のHPが同時に0になりました。' : `${gameState.players[winnerIndex].name}の勝利！`;

            content.innerHTML = `
                <h2>${title}</h2>
                <p>${msg}</p>
                
                <!-- プレイヤー1の成績 -->
                <div style="background: rgba(255,107,107,0.1); border: 2px solid rgba(255,107,107,0.3); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                    <h3 style="margin: 0 0 15px 0; color: #ff6b6b; text-align: center; display: flex; align-items: center; justify-content: center; gap: 10px;">
                        ${gameState.players[0].avatar} ${gameState.players[0].name}の成績
                    </h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; font-size: 14px;">
                        <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                            <div style="font-size: 20px; font-weight: 700; color: #4ecdc4;">${p1Accuracy}%</div>
                            <div style="opacity: 0.8; font-size: 12px;">正確さ</div>
                            <div style="font-size: 11px; opacity: 0.6;">${player1Stats.correctChars}/${player1Stats.totalChars}文字</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                            <div style="font-size: 20px; font-weight: 700; color: #feca57;">${p1Speed}</div>
                            <div style="opacity: 0.8; font-size: 12px;">文字/分</div>
                            <div style="font-size: 11px; opacity: 0.6;">平均速度</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                            <div style="font-size: 20px; font-weight: 700; color: #ff6b6b;">${player1Stats.maxCombo}</div>
                            <div style="opacity: 0.8; font-size: 12px;">最大コンボ</div>
                            <div style="font-size: 11px; opacity: 0.6;">連続成功</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                            <div style="font-size: 20px; font-weight: 700; color: #95e1d3;">${Math.round(player1Stats.totalTime)}秒</div>
                            <div style="opacity: 0.8; font-size: 12px;">総入力時間</div>
                            <div style="font-size: 11px; opacity: 0.6;">実際の入力</div>
                        </div>
                    </div>
                </div>
                
                <!-- プレイヤー2の成績 -->
                <div style="background: rgba(76,224,196,0.1); border: 2px solid rgba(76,224,196,0.3); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                    <h3 style="margin: 0 0 15px 0; color: #4ecdc4; text-align: center; display: flex; align-items: center; justify-content: center; gap: 10px;">
                        ${gameState.players[1].avatar} ${gameState.players[1].name}の成績
                    </h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; font-size: 14px;">
                        <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                            <div style="font-size: 20px; font-weight: 700; color: #4ecdc4;">${p2Accuracy}%</div>
                            <div style="opacity: 0.8; font-size: 12px;">正確さ</div>
                            <div style="font-size: 11px; opacity: 0.6;">${player2Stats.correctChars}/${player2Stats.totalChars}文字</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                            <div style="font-size: 20px; font-weight: 700; color: #feca57;">${p2Speed}</div>
                            <div style="opacity: 0.8; font-size: 12px;">文字/分</div>
                            <div style="font-size: 11px; opacity: 0.6;">平均速度</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                            <div style="font-size: 20px; font-weight: 700; color: #ff6b6b;">${player2Stats.maxCombo}</div>
                            <div style="opacity: 0.8; font-size: 12px;">最大コンボ</div>
                            <div style="font-size: 11px; opacity: 0.6;">連続成功</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                            <div style="font-size: 20px; font-weight: 700; color: #95e1d3;">${Math.round(player2Stats.totalTime)}秒</div>
                            <div style="opacity: 0.8; font-size: 12px;">総入力時間</div>
                            <div style="font-size: 11px; opacity: 0.6;">実際の入力</div>
                        </div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="restartGame()">もう一度</button>
                    <button class="btn btn-primary" onclick="backToMenu()">メニューへ戻る</button>
                </div>
            `;
            modal.style.display = 'flex';
        }

        // 音声再生
        function playSound(type) {
            if (!gameState.soundEnabled) return;
            
            ensureAudio();
            if (!audioCtx) return;
            
            // 確実な起動のため再生直前でもresume
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            // 簡易音声（実際の実装では適切な音声ファイルを使用）
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'success') {
                oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.1); // E5
            } else if (type === 'attack') {
                // 攻撃音：力強い低音から高音へ
                oscillator.frequency.setValueAtTime(150, audioCtx.currentTime); // 低音
                oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.2);
                oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.4);
            } else if (type === 'heal') {
                // 回復音：美しい和音
                oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioCtx.currentTime + 0.2); // G5
                oscillator.frequency.setValueAtTime(1046.50, audioCtx.currentTime + 0.3); // C6
            } else if (type === 'charge') {
                // 溜め音：低音から高音へ
                oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.3);
            } else {
                oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); // A3
            }
            
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (type === 'heal' ? 0.5 : type === 'attack' ? 0.4 : 0.3));
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + (type === 'heal' ? 0.5 : type === 'attack' ? 0.4 : 0.3));
        }

        // モーダル表示
        function showModal(title, content) {
            document.getElementById('modalContent').innerHTML = `
                <h2>${title}</h2>
                ${content}
            `;
            document.getElementById('modal').style.display = 'flex';
        }

        // モーダル非表示
        function hideModal() {
            document.getElementById('modal').style.display = 'none';
        }

        // ヘルプ表示
        function showHelp() {
            showModal('📖 ゲームの遊び方', `
                <p><strong>基本ルール</strong></p>
                <p>• 設定したHPでスタート</p>
                <p>• 手札から1枚選んでタイピング</p>
                <p>• 12秒以内にローマ字で入力</p>
                <p>• 成功：文字数×残り時間でダメージ</p>
                <p>• 失敗：文字数×5の自傷ダメージ</p>
                <p>• 打ち間違え：2秒ペナルティ</p>
                <p>• 長音「ー」はハイフン「-」で入力</p>
                <p>• 「ん」は n, nn, n', m（次が b/m/p の場合）</p>
                <p><strong>💚 医療カード</strong></p>
                <p>• 緑色のオーラが目印</p>
                <p>• 成功すると自分のHPが回復</p>
                <p>• 回復量：文字数×残り時間</p>
                <p><strong>操作方法</strong></p>
                <p>• カードをタップして選択</p>
                <p>• ローマ字で入力（全角でもOK）</p>
                <p>• ESCキーでギブアップ</p>
                <button class="btn btn-primary" onclick="hideModal()">閉じる</button>
            `);
        }

        // 音量切り替え
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            document.getElementById('soundBtn').textContent = gameState.soundEnabled ? '🔊' : '🔇';
        }

        // ゲーム一時停止
        function pauseGame() {
            if (gameState.gamePhase !== 'typing') return;

            if (!gameState.isPaused) {
                gameState.isPaused = true;
                stopTimer(); // rAF停止でCPU消費を抑制
                document.getElementById('pauseBtn').textContent = '▶️';
                showModal('⏸️ 一時停止', `
                    <p>ゲームを一時停止しました</p>
                    <button class="btn btn-primary" onclick="resumeGame()">再開</button>
                `);
            } else {
                resumeGame();
            }
        }

        // ゲーム再開
        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseBtn').textContent = '⏸️';
            hideModal();
            // 期限は保持してあるので残り時間で再開
            const remainingMs = Math.max(0, timerDeadline - performance.now());
            if (remainingMs > 0) {
                startAccurateTimer(remainingMs);
            }
        }

        // メニューに戻る
        function backToMenu() {
            // ゲーム状態リセット
            gameState = {
                mode: null,
                maxHP: 200,
                players: [
                    { name: 'プレイヤー1', hp: 200, maxHp: 200, avatar: '🔥', attribute: 'fire' },
                    { name: 'CPU', hp: 200, maxHp: 200, avatar: '🤖', attribute: 'water' }
                ],
                currentPlayer: 0,
                selectedCard: null,
                hands: [[], []],
                deck: [],
                discard: [],
                timer: 15,
                timerInterval: null,
                gamePhase: 'cardSelect',
                soundEnabled: true,
                isPaused: false,
                playerStats: [
                    { totalChars: 0, correctChars: 0, totalTime: 0, combo: 0, maxCombo: 0 },
                    { totalChars: 0, correctChars: 0, totalTime: 0, combo: 0, maxCombo: 0 }
                ],
                stats: {
                    totalChars: 0,
                    correctChars: 0,
                    totalTime: 0,
                    combo: 0,
                    maxCombo: 0
                }
            };
            
            stopTimer();
            hideModal();
            document.getElementById('gameContainer').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('characterSelection').classList.add('hidden');
            document.getElementById('gameRules').classList.add('hidden');
            document.getElementById('player2Setup').classList.add('hidden');
            
            // 選択状態をリセット
            document.querySelectorAll('.mode-btn, .character-btn, .hp-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // デフォルトHP選択
            document.querySelector('[data-hp="200"]').classList.add('selected');
            
            // 名前入力をリセット
            document.getElementById('player1NameInput').value = 'プレイヤー1';
            document.getElementById('player2NameInput').value = 'プレイヤー2';
            document.getElementById('nextBtn').disabled = true;
        }

        // ゲーム再開始
        function restartGame() {
            hideModal();
            
            // HP回復
            gameState.players.forEach(player => {
                player.hp = player.maxHp;
            });
            
            // 統計リセット（両プレイヤー分）
            gameState.playerStats = [
                { totalChars: 0, correctChars: 0, totalTime: 0, combo: 0, maxCombo: 0 },
                { totalChars: 0, correctChars: 0, totalTime: 0, combo: 0, maxCombo: 0 }
            ];
            gameState.stats = {
                totalChars: 0,
                correctChars: 0,
                totalTime: 0,
                combo: 0,
                maxCombo: 0
            };
            
            // ゲーム状態リセット
            gameState.currentPlayer = 0;
            gameState.gamePhase = 'cardSelect';
            gameState.selectedCard = null;
            gameState.hands = [[], []];
            gameState.deck = [];
            gameState.discard = [];
            stopTimer();
            
            // 2人対戦の場合はルーレットでターン決定
            if (gameState.mode === 'pvp') {
                showRouletteAnimation().then(() => {
                    initGame();
                });
            } else {
                initGame();
            }
        }

        // イベントリスナー
        document.addEventListener('DOMContentLoaded', function() {
            // モーダルクリックで閉じる
            document.getElementById('modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideModal();
                }
            });

            // 名前入力フィールドのイベントリスナー
            document.getElementById('player1NameInput').addEventListener('input', function() {
                gameState.players[0].name = this.value || 'プレイヤー1';
                checkSetupComplete();
            });

            document.getElementById('player2NameInput').addEventListener('input', function() {
                gameState.players[1].name = this.value || 'プレイヤー2';
                checkSetupComplete();
            });
        });

        // モバイル安全装置（画面離脱でタイマー暴走を防止）
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.gamePhase === 'typing') {
                gameState.isPaused = true;
            }
        });

        // 追加の必要な関数
        function showPenaltyEffect() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 300);
        }

        function showHelp() {
            showModal('📖 ゲームの遊び方', `
                <p><strong>基本ルール</strong></p>
                <p>• 設定したHPでスタート</p>
                <p>• 手札から1枚選んでタイピング</p>
                <p>• 12秒以内にローマ字で入力</p>
                <p>• 成功：文字数×残り時間でダメージ</p>
                <p>• 失敗：文字数×5の自傷ダメージ</p>
                <p>• 打ち間違え：2秒ペナルティ</p>
                <p>• 長音「ー」はハイフン「-」で入力</p>
                <p>• 「ん」は n, nn, n', m（次が b/m/p の場合）</p>
                <p><strong>💚 医療カード</strong></p>
                <p>• 緑色のオーラが目印</p>
                <p>• 成功すると自分のHPが回復</p>
                <p>• 回復量：文字数×残り時間</p>
                <p><strong>操作方法</strong></p>
                <p>• カードをタップして選択</p>
                <p>• ローマ字で入力（全角でもOK）</p>
                <p>• ESCキーでギブアップ</p>
                <button class="btn btn-primary" onclick="hideModal()">閉じる</button>
            `);
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const btn = document.getElementById('soundBtn');
            if (btn) btn.textContent = gameState.soundEnabled ? '🔊' : '🔇';
        }

        function pauseGame() {
            if (gameState.gamePhase !== 'typing') return;

            if (!gameState.isPaused) {
                gameState.isPaused = true;
                stopTimer();
                document.getElementById('pauseBtn').textContent = '▶️';
                showModal('⏸️ 一時停止', `
                    <p>ゲームを一時停止しました</p>
                    <button class="btn btn-primary" onclick="resumeGame()">再開</button>
                `);
            } else {
                resumeGame();
            }
        }

        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseBtn').textContent = '⏸️';
            hideModal();
            const remainingMs = Math.max(0, timerDeadline - performance.now());
            if (remainingMs > 0) {
                startAccurateTimer(remainingMs);
            }
        }

        function backToMenu() {
            location.reload();
        }

        function submitAnswer() {
            if (!gameState.selectedCard) return;
            
            disableTyping();
            stopTimer();
            
            const card = gameState.selectedCard;
            const isHeal = card.category === 'いりょう';
            const baseLen = countChars(card.text);
            const leftMs = Math.max(0, timerDeadline - performance.now());
            const remainingTime = Math.ceil(leftMs / 1000);
            
            const success = typingState.currentInputs.some(input => input.completed);
            
            if (success) {
                const amount = baseLen * Math.max(1, remainingTime);
                if (isHeal) {
                    addHp(gameState.currentPlayer, amount);
                    showFloatingNumber(amount, gameState.currentPlayer, true);
                    playSound('heal');
                } else {
                    addHp(1 - gameState.currentPlayer, -amount);
                    showFloatingNumber(amount, 1 - gameState.currentPlayer, false);
                    playSound('attack');
                }
            } else {
                const selfDamage = baseLen * 5;
                addHp(gameState.currentPlayer, -selfDamage);
                showFloatingNumber(selfDamage, gameState.currentPlayer, false);
                playSound('fail');
            }
            
            // カードを手札から削除
            const hand = gameState.hands[gameState.currentPlayer];
            const cardIndex = hand.indexOf(card);
            if (cardIndex > -1) {
                hand.splice(cardIndex, 1);
            }
            
            // 新しいカードを引く
            if (gameState.deck.length > 0 && hand.length < 6) {
                hand.push(gameState.deck.pop());
            }
            
            gameState.selectedCard = null;
            clearTypingDisplay();
            
            // 勝敗チェック
            const p1Dead = gameState.players[0].hp <= 0;
            const p2Dead = gameState.players[1].hp <= 0;
            
            if (p1Dead || p2Dead) {
                const winner = p1Dead && p2Dead ? null : (p1Dead ? 1 : 0);
                setTimeout(() => endGame(winner), 500);
                return;
            }
            
            // ターン交代
            setTimeout(() => {
                gameState.currentPlayer = 1 - gameState.currentPlayer;
                gameState.gamePhase = 'cardSelect';
                startTurn();
            }, 800);
        }

        function giveUp() {
            timeUp();
        }

        function timeUp() {
            if (!gameState.selectedCard || gameState.gamePhase !== 'typing') return;
            
            disableTyping();
            clearTypingDisplay();
            
            const card = gameState.selectedCard;
            const selfDamage = countChars(card.text) * 5;
            
            addHp(gameState.currentPlayer, -selfDamage);
            showFloatingNumber(selfDamage, gameState.currentPlayer, false);
            playSound('fail');
            
            // カードを手札から削除
            const hand = gameState.hands[gameState.currentPlayer];
            const cardIndex = hand.indexOf(card);
            if (cardIndex > -1) {
                hand.splice(cardIndex, 1);
            }
            
            // 新しいカードを引く
            if (gameState.deck.length > 0 && hand.length < 6) {
                hand.push(gameState.deck.pop());
            }
            
            gameState.selectedCard = null;
            
            // 勝敗チェック
            const p1Dead = gameState.players[0].hp <= 0;
            const p2Dead = gameState.players[1].hp <= 0;
            
            if (p1Dead || p2Dead) {
                const winner = p1Dead && p2Dead ? null : (p1Dead ? 1 : 0);
                setTimeout(() => endGame(winner), 500);
                return;
            }
            
            // ターン交代
            setTimeout(() => {
                gameState.currentPlayer = 1 - gameState.currentPlayer;
                gameState.gamePhase = 'cardSelect';
                startTurn();
            }, 800);
        }

        // HP管理の統一関数
        function setHp(playerIndex, value) {
            const player = gameState.players[playerIndex];
            player.hp = Math.max(0, Math.min(player.maxHp, value));
            updateUI();
        }

        function addHp(playerIndex, delta) {
            setHp(playerIndex, gameState.players[playerIndex].hp + delta);
        }

        // 浮遊ダメージ数値表示
        function showFloatingNumber(num, playerIndex, isHeal) {
            const target = document.getElementById(`player${playerIndex + 1}Avatar`);
            const rect = target.getBoundingClientRect();
            const n = document.createElement('div');
            n.className = 'damage-number' + (isHeal ? ' heal' : '');
            n.style.left = rect.left + rect.width / 2 + 'px';
            n.style.top = rect.top + 'px';
            n.textContent = (isHeal ? '+' : '-') + num;
            document.body.appendChild(n);
            setTimeout(() => n.remove(), 1600);
        }

        // ===== 最小スタブ＆進行ロジック =====
        
        // ターン開始：手札描画→カード選択フェーズへ
        function startTurn(){
            gameState.gamePhase = 'cardSelect';
            clearTypingDisplay();
            disableTyping();
            stopTimer();
            updateUI();
            drawPlayerHand();
            drawCards();
            
            // CPU判定
            if (gameState.mode === 'cpu' && gameState.currentPlayer === 1) {
                setTimeout(cpuAct, 700);
            }
        }

        // ターン終了→相手に交代
        function endTurn(){
            gameState.selectedCard = null;
            gameState.currentPlayer = 1 - gameState.currentPlayer;
            startTurn();
        }

        // タイムアップ（失敗扱い）
        function timeUp(){
            if (!gameState.selectedCard) { endTurn(); return; }
            
            disableTyping();
            clearTypingDisplay();
            
            const len = countChars(gameState.selectedCard.text);
            const self = gameState.currentPlayer;
            gameState.players[self].hp = Math.max(0, gameState.players[self].hp - len * 5);
            
            // 使ったカードを手札から捨てる
            const hand = gameState.hands[self];
            const idx = hand.indexOf(gameState.selectedCard);
            if (idx >= 0) hand.splice(idx, 1);
            
            updateUI();
            
            // 勝敗チェック
            if (gameState.players[0].hp <= 0 || gameState.players[1].hp <= 0) {
                const winner = gameState.players[0].hp <= 0 ? 1 : 0;
                setTimeout(() => endGame(winner), 500);
                return;
            }
            
            setTimeout(() => endTurn(), 800);
        }

        // 答え送信（成功ダメージ／回復）
        function submitAnswer(){
            if (!gameState.selectedCard) return;

            disableTyping();
            stopTimer();

            // 残り時間からダメージ/回復量を概算
            const msLeft = Math.max(0, timerDeadline - performance.now());
            const remainSec = Math.max(1, Math.ceil(msLeft / 1000));
            const len = countChars(gameState.selectedCard.text);
            const amount = len * remainSec;

            const me = gameState.currentPlayer;
            const opp = 1 - me;

            // 使ったカードを手札から捨てる
            const hand = gameState.hands[me];
            const idx = hand.indexOf(gameState.selectedCard);
            if (idx >= 0) hand.splice(idx, 1);

            // 回復カード（カテゴリ：いりょう）は回復、それ以外は攻撃
            if (gameState.selectedCard.category === 'いりょう') {
                gameState.players[me].hp = Math.min(gameState.players[me].maxHp, gameState.players[me].hp + amount);
                showFloatingNumber(amount, me, true);
                playSound('heal');
            } else {
                gameState.players[opp].hp = Math.max(0, gameState.players[opp].hp - amount);
                showFloatingNumber(amount, opp, false);
                playSound('attack');
            }

            clearTypingDisplay();
            updateUI();
            
            // 勝敗チェック
            if (gameState.players[0].hp <= 0 || gameState.players[1].hp <= 0) {
                const winner = gameState.players[0].hp <= 0 ? 1 : 0;
                setTimeout(() => endGame(winner), 500);
                return;
            }
            
            setTimeout(() => endTurn(), 800);
        }

        // ギブアップ＝即失敗
        function giveUp(){
            stopTimer();
            timeUp();
        }

        // 初期化
        console.log('🎮 タイピングバトル - 学習ゲーム');
        console.log('📝 カード追加方法: CARD_POOL配列に新しいオブジェクトを追加');
        console.log('🎨 属性カスタマイズ: CSS変数 --attr-color を変更');
        console.log('🔊 音声カスタマイズ: playSound関数を編集');
        /* ====== 必須ロジックの最小実装（ゲームが進む） ====== */

// 効果音（簡易）
function playSound(type) {
    if (!gameState.soundEnabled) return;
    ensureAudio();
    if (!audioCtx) return;

    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const ENDS = now + 0.12;

    // 種類別ピッチ
    const freq = ({
        success: 880,
        fail: 220,
        charge: 440
    })[type] || 660;

    osc.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0.08, now);
    g.gain.exponentialRampToValueAtTime(0.001, ENDS);

    osc.start(now);
    osc.stop(ENDS);
}

// ダメージ/回復の共通反映
function applyHp(targetIndex, delta) {
    const p = gameState.players[targetIndex];
    p.hp = Math.max(0, Math.min(p.maxHp, p.hp + delta)); // deltaは回復なら正、ダメージなら負
    updateUI();

    // 敗北/勝利判定
    if (p.hp <= 0) {
        stopTimer();
        disableTyping();
        showModal(`${gameState.players[1 - targetIndex].name} の勝ち！`, `${gameState.players[targetIndex].name} は倒れた…`);
    }
}

// ざっくりモーダル（既存 #modal を利用）
function showModal(title, text) {
    const modal = document.getElementById('modal');
    const content = document.getElementById('modalContent');
    content.innerHTML = `<h2>${title}</h2><p>${text}</p><button class="btn btn-primary" id="modalOk">OK</button>`;
    modal.style.display = 'flex';
    document.getElementById('modalOk').onclick = () => { modal.style.display = 'none'; };
}

// 進行の起点：ターン開始
function startTurn() {
    gameState.gamePhase = 'cardSelect';
    clearTypingDisplay();
    updatePhaseDisplay();
    updateUI();
    drawPlayerHand();
    drawCards();

    // タイマー表示初期化
    const ring = document.getElementById('timerRing');
    ring.textContent = '12';
    ring.style.background = 'conic-gradient(#feca57 360deg, rgba(255,255,255,0.2) 360deg)';

    // CPU 戦ならCPUの番で自動行動
    if (gameState.mode === 'cpu' && gameState.currentPlayer === 1) {
        setTimeout(cpuTurn, 700);
    }
}

// CPUの簡易AI（80%成功／3〜10秒残し）
function cpuTurn() {
    const hand = gameState.hands[1];
    if (!hand.length) return endTurn(); // 念のため

    const pick = Math.min(5, hand.length - 1); // 表示6枚のうち末尾
    gameState.selectedCard = hand[pick];

    // 成功/失敗
    const succeed = Math.random() < 0.8;
    if (succeed) {
        const msLeft = (3000 + Math.random() * 7000); // 3〜10秒
        const sec = Math.ceil(msLeft / 1000);
        const base = countChars(gameState.selectedCard.text);
        const amount = Math.max(1, base * sec);

        // 攻撃 or 回復
        if (gameState.selectedCard.category === 'いりょう') {
            applyHp(1, +amount);
        } else {
            // 演出（省略可）
            const targetEl = document.getElementById('player1Avatar');
            const fromSide = 'right';
            playAttackAnimation({
                attr: gameState.players[1].attribute,
                from: fromSide,
                targetEl
            }).catch(()=>{});
            applyHp(0, -amount);
        }
    } else {
        const selfdmg = countChars(gameState.selectedCard.text) * 5;
        applyHp(1, -selfdmg);
    }
    endTurn();
}

// 入力完了（Enter不要・自動で呼ばれる想定）
function submitAnswer() {
    if (!gameState.selectedCard) return;

    // 残り時間からダメージ計算
    const msLeft = Math.max(0, timerDeadline - performance.now());
    const sec = Math.ceil(msLeft / 1000);
    const base = countChars(gameState.selectedCard.text);
    const amount = Math.max(1, base * sec);

    stopTimer();
    disableTyping();

    const me = gameState.currentPlayer;
    const opp = 1 - me;

    if (gameState.selectedCard.category === 'いりょう') {
        applyHp(me, +amount);
    } else {
        // 攻撃演出（相手アバターをターゲット）
        const targetEl = document.getElementById(`player${opp + 1}Avatar`);
        const fromSide = (me === 0) ? 'left' : 'right';
        playAttackAnimation({
            attr: gameState.players[me].attribute,
            from: fromSide,
            targetEl
        }).catch(()=>{});
        applyHp(opp, -amount);
    }
    endTurn();
}

// 時間切れ（失敗）
function timeUp() {
    if (!gameState.selectedCard) return;
    disableTyping();

    const selfdmg = countChars(gameState.selectedCard.text) * 5;
    const me = gameState.currentPlayer;
    applyHp(me, -selfdmg);
    endTurn();
}

// ギブアップ（ESC）
function giveUp() {
    if (!gameState.selectedCard) return;
    stopTimer();
    disableTyping();

    const selfdmg = countChars(gameState.selectedCard.text) * 5;
    const me = gameState.currentPlayer;
    applyHp(me, -selfdmg);
    endTurn();
}

// ペナルティの視覚効果（間違いキー時）
function showPenaltyEffect() {
    const tg = document.getElementById('typingGuide');
    tg.classList.add('shake');
    setTimeout(() => tg.classList.remove('shake'), 300);
}

// ターン終了 → 手札整理 → 手番交代 → 次ターンへ
function endTurn() {
    // 使用カードを捨て札へ
    const hand = gameState.hands[gameState.currentPlayer];
    const idx = hand.indexOf(gameState.selectedCard);
    if (idx >= 0) {
        gameState.discard.push(hand.splice(idx, 1)[0]);
    }
    gameState.selectedCard = null;

    // 山から補充（常に6枚以下に）
    if (gameState.deck.length && hand.length < 6) {
        hand.push(gameState.deck.pop());
    }

    // 勝敗が出ていればここで止める
    if (gameState.players[0].hp <= 0 || gameState.players[1].hp <= 0) return;

    // 手番交代
    gameState.currentPlayer = 1 - gameState.currentPlayer;
    startTurn();
}

/* ========== 各種ボタンの最小実装 ========== */
function showHelp() {
    showModal('ヘルプ', 'カードを選び、表示されたことばをローマ字で入力します。成功すると残り時間に応じて攻撃（または回復）。失敗やギブアップは自傷になります。');
}
function toggleSound() {
    gameState.soundEnabled = !gameState.soundEnabled;
    document.getElementById('soundBtn').textContent = gameState.soundEnabled ? '🔊' : '🔇';
}
function pauseGame() {
    gameState.isPaused = !gameState.isPaused;
    if (gameState.isPaused) { stopTimer(); }
    else if (gameState.gamePhase === 'typing') { startTimer(); }
    document.getElementById('pauseBtn').textContent = gameState.isPaused ? '▶️' : '⏸️';
}
function backToMenu() {
    stopTimer(); disableTyping();
    location.reload(); // シンプルにリロードで開始画面へ
}
<script>
// ====== [Fix] ラウンド解決の二重実行ガード ======
let resolving = false;

// 残り秒を整数で取得（リング表示と同じ丸めに合わせる）
function getSecondsLeft() {
  const msLeft = Math.max(0, timerDeadline - performance.now());
  return Math.ceil(msLeft / 1000);
}

// 失敗（タイムアップ）時の処理
function timeUp() {
  if (gameState.gamePhase !== 'typing' || resolving) return;
  resolving = true;
  disableTyping();
  const target = gameState.selectedCard?.text || '';
  const selfDmg = countChars(target) * 5; // 仕様どおり：失敗は文字数×5 自傷
  applyDamage(gameState.currentPlayer, selfDmg, /*self=*/true);
  // 見た目をクリア
  clearTypingDisplay();
  // ラウンド後処理へ
  afterResolveRound(false);
}

// 成功（Enter または自動完了）時の処理
function submitAnswer() {
  if (gameState.gamePhase !== 'typing' || resolving) return;
  resolving = true;
  disableTyping();
  stopTimer();

  const text = gameState.selectedCard?.text || '';
  const len = countChars(text);
  const secLeft = getSecondsLeft(); // 仕様：文字数 × 残り時間（秒）
  const dmg = Math.max(1, secLeft) * len;

  // 攻撃は相手へ
  applyDamage(1 - gameState.currentPlayer, dmg, /*self=*/false);

  // 見た目をクリア
  clearTypingDisplay();

  // ラウンド後処理へ
  afterResolveRound(true);
}

// ダメージ適用＆UI更新
function applyDamage(targetPlayerIndex, amount, self = false) {
  gameState.players[targetPlayerIndex].hp = Math.max(0, gameState.players[targetPlayerIndex].hp - amount);
  updateUI();
}

// ラウンド解決後の共通処理
function afterResolveRound(success) {
  // 選んだカードを捨て札へ（手札から除外）
  if (gameState.selectedCard) {
    const hand = gameState.hands[gameState.currentPlayer];
    const idx = hand.indexOf(gameState.selectedCard);
    if (idx >= 0) hand.splice(idx, 1);
    gameState.discard.push(gameState.selectedCard);
  }
  gameState.selectedCard = null;

  // ゲーム終了チェック → 結果モーダルを**ここで必ず**出す
  if (checkGameOver()) {
    resolving = false;
    return;
  }

  // 次ターンへ
  gameState.currentPlayer = 1 - gameState.currentPlayer;
  gameState.gamePhase = 'cardSelect';
  updatePhaseDisplay();
  drawPlayerHand();
  drawCards();
  updateUI();
  resolving = false;
}

// 終了条件と結果表示
function checkGameOver() {
  const p0 = gameState.players[0];
  const p1 = gameState.players[1];

  const hpEnd = (p0.hp <= 0 || p1.hp <= 0);
  const noMoreCards = (gameState.deck.length === 0 &&
                       gameState.hands[0].length === 0 &&
                       gameState.hands[1].length === 0);

  if (!hpEnd && !noMoreCards) return false;

  stopTimer();
  disableTyping();

  showSummaryModal();
  return true;
}

function showSummaryModal() {
  const p0 = gameState.players[0], p1 = gameState.players[1];
  let winnerText = '引き分け';
  if (p0.hp !== p1.hp) {
    winnerText = (p1.hp <= 0 || p0.hp > p1.hp) ? `${p0.name}` : `${p1.name}`;
  }

  const modal = document.getElementById('modal');
  const content = document.getElementById('modalContent');
  content.innerHTML = `
    <h2>結果</h2>
    <p><strong>勝者：</strong>${winnerText}</p>
    <p>${p0.name}：${p0.hp}/${p0.maxHp}　｜　${p1.name}：${p1.hp}/${p1.maxHp}</p>
    <div style="margin-top:16px; display:flex; gap:10px; justify-content:center;">
      <button class="btn btn-primary" id="retryBtn">もう一度</button>
      <button class="btn btn-secondary" id="backBtn">メニューへ</button>
    </div>
  `;
  modal.style.display = 'flex';

  document.getElementById('retryBtn').onclick = () => {
    modal.style.display = 'none';
    resetAndRestart();
  };
  document.getElementById('backBtn').onclick = () => {
    modal.style.display = 'none';
    backToMenu();
  };
}

function resetAndRestart() {
  // 最低限のリセットで再開
  stopTimer();
  disableTyping();
  clearTypingDisplay();

  gameState.deck = [];
  gameState.discard = [];
  gameState.hands = [[], []];
  gameState.selectedCard = null;
  gameState.gamePhase = 'cardSelect';
  resolving = false;

  initGame();
}

// backToMenuが未実装なら最低限の戻し
if (typeof backToMenu !== 'function') {
  function backToMenu() {
    // スタート画面に戻す
    document.getElementById('gameContainer').classList.add('hidden');
    document.getElementById('startScreen').classList.remove('hidden');
    stopTimer();
    disableTyping();
  }
}
</script>       
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'977b0e14f587d521',t:'MTc1NjYyNzg2NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
